// generated by make_pydocs.py

package org.python.core;

public class BuiltinDocs {

    // Docs for <class 'object'>
    public final static String object___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String object___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String object___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String object_doc = 
        "The most base type";

    public final static String object___eq___doc = 
        "Return self==value.";

    public final static String object___format___doc = 
        "default object formatter";

    public final static String object___ge___doc = 
        "Return self>=value.";

    public final static String object___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String object___gt___doc = 
        "Return self>value.";

    public final static String object___hash___doc = 
        "Return hash(self).";

    public final static String object___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String object___le___doc = 
        "Return self<=value.";

    public final static String object___lt___doc = 
        "Return self<value.";

    public final static String object___ne___doc = 
        "Return self!=value.";

    public final static String object___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String object___reduce___doc = 
        "helper for pickle";

    public final static String object___reduce_ex___doc = 
        "helper for pickle";

    public final static String object___repr___doc = 
        "Return repr(self).";

    public final static String object___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String object___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String object___str___doc = 
        "Return str(self).";

    public final static String object___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'type'>
    public final static String type___abstractmethods___doc = 
        "";

    public final static String type___base___doc = 
        "The most base type";

    public final static String type___bases___doc = 
        "tuple() -> empty tuple\n" + 
        "tuple(iterable) -> tuple initialized from iterable's items\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String type___basicsize___doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String type___call___doc = 
        "Call self as a function.";

    public final static String type___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String type___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String type___dict___doc = 
        "";

    public final static String type___dictoffset___doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String type___dir___doc = 
        "__dir__() -> list\n" + 
        "specialized __dir__ implementation for types";

    public final static String type_doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String type___eq___doc = 
        "Return self==value.";

    public final static String type___flags___doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String type___format___doc = 
        "default object formatter";

    public final static String type___ge___doc = 
        "Return self>=value.";

    public final static String type___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String type___gt___doc = 
        "Return self>value.";

    public final static String type___hash___doc = 
        "Return hash(self).";

    public final static String type___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String type___instancecheck___doc = 
        "__instancecheck__() -> bool\n" + 
        "check if an object is an instance";

    public final static String type___itemsize___doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String type___le___doc = 
        "Return self<=value.";

    public final static String type___lt___doc = 
        "Return self<value.";

    public final static String type___module___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String type___mro___doc = 
        "tuple() -> empty tuple\n" + 
        "tuple(iterable) -> tuple initialized from iterable's items\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String type___name___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String type___ne___doc = 
        "Return self!=value.";

    public final static String type___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String type___prepare___doc = 
        "__prepare__() -> dict\n" + 
        "used to create the namespace for the class statement";

    public final static String type___qualname___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String type___reduce___doc = 
        "helper for pickle";

    public final static String type___reduce_ex___doc = 
        "helper for pickle";

    public final static String type___repr___doc = 
        "Return repr(self).";

    public final static String type___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String type___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "return memory consumption of the type object";

    public final static String type___str___doc = 
        "Return str(self).";

    public final static String type___subclasscheck___doc = 
        "__subclasscheck__() -> bool\n" + 
        "check if a class is a subclass";

    public final static String type___subclasses___doc = 
        "__subclasses__() -> list of immediate subclasses";

    public final static String type___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String type___text_signature___doc = 
        "";

    public final static String type___weakrefoffset___doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String type_mro_doc = 
        "mro() -> list\n" + 
        "return a type's method resolution order";

    // Docs for <class 'bytes'>
    public final static String bytes___add___doc = 
        "Return self+value.";

    public final static String bytes___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bytes___contains___doc = 
        "Return key in self.";

    public final static String bytes___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String bytes___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String bytes_doc = 
        "bytes(iterable_of_ints) -> bytes\n" + 
        "bytes(string, encoding[, errors]) -> bytes\n" + 
        "bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\n" + 
        "bytes(int) -> bytes object of size given by the parameter initialized with null bytes\n" + 
        "bytes() -> empty bytes object\n" + 
        "\n" + 
        "Construct an immutable array of bytes from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - any object implementing the buffer API.\n" + 
        "  - an integer";

    public final static String bytes___eq___doc = 
        "Return self==value.";

    public final static String bytes___format___doc = 
        "default object formatter";

    public final static String bytes___ge___doc = 
        "Return self>=value.";

    public final static String bytes___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String bytes___getitem___doc = 
        "Return self[key].";

    public final static String bytes___getnewargs___doc = 
        "";

    public final static String bytes___gt___doc = 
        "Return self>value.";

    public final static String bytes___hash___doc = 
        "Return hash(self).";

    public final static String bytes___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String bytes___iter___doc = 
        "Implement iter(self).";

    public final static String bytes___le___doc = 
        "Return self<=value.";

    public final static String bytes___len___doc = 
        "Return len(self).";

    public final static String bytes___lt___doc = 
        "Return self<value.";

    public final static String bytes___mod___doc = 
        "Return self%value.";

    public final static String bytes___mul___doc = 
        "Return self*value.n";

    public final static String bytes___ne___doc = 
        "Return self!=value.";

    public final static String bytes___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String bytes___reduce___doc = 
        "helper for pickle";

    public final static String bytes___reduce_ex___doc = 
        "helper for pickle";

    public final static String bytes___repr___doc = 
        "Return repr(self).";

    public final static String bytes___rmod___doc = 
        "Return value%self.";

    public final static String bytes___rmul___doc = 
        "Return self*value.";

    public final static String bytes___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String bytes___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String bytes___str___doc = 
        "Return str(self).";

    public final static String bytes___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bytes_capitalize_doc = 
        "B.capitalize() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with only its first character capitalized (ASCII)\n" + 
        "and the rest lower-cased.";

    public final static String bytes_center_doc = 
        "B.center(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B centered in a string of length width.  Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytes_count_doc = 
        "B.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "string B[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String bytes_decode_doc = 
        "Decode the bytes using the codec registered for encoding.\n" + 
        "\n" + 
        "  encoding\n" + 
        "    The encoding with which to decode the bytes.\n" + 
        "  errors\n" + 
        "    The error handling scheme to use for the handling of decoding errors.\n" + 
        "    The default is 'strict' meaning that decoding errors raise a\n" + 
        "    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "    as well as any other name registered with codecs.register_error that\n" + 
        "    can handle UnicodeDecodeErrors.";

    public final static String bytes_endswith_doc = 
        "B.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "suffix can also be a tuple of bytes to try.";

    public final static String bytes_expandtabs_doc = 
        "B.expandtabs(tabsize=8) -> copy of B\n" + 
        "\n" + 
        "Return a copy of B where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String bytes_find_doc = 
        "B.find(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where substring sub is found,\n" + 
        "such that sub is contained within B[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytes_fromhex_doc = 
        "Create a bytes object from a string of hexadecimal numbers.\n" + 
        "\n" + 
        "Spaces between two numbers are accepted.\n" + 
        "Example: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.";

    public final static String bytes_hex_doc = 
        "B.hex() -> string\n" + 
        "\n" + 
        "Create a string of hexadecimal numbers from a bytes object.\n" + 
        "Example: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'.";

    public final static String bytes_index_doc = 
        "B.index(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Like B.find() but raise ValueError when the substring is not found.";

    public final static String bytes_isalnum_doc = 
        "B.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphanumeric\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_isalpha_doc = 
        "B.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphabetic\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_isdigit_doc = 
        "B.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are digits\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_islower_doc = 
        "B.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are lowercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytes_isspace_doc = 
        "B.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are whitespace\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_istitle_doc = 
        "B.istitle() -> bool\n" + 
        "\n" + 
        "Return True if B is a titlecased string and there is at least one\n" + 
        "character in B, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String bytes_isupper_doc = 
        "B.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are uppercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytes_join_doc = 
        "Concatenate any number of bytes objects.\n" + 
        "\n" + 
        "The bytes whose method is called is inserted in between each pair.\n" + 
        "\n" + 
        "The result is returned as a new bytes object.\n" + 
        "\n" + 
        "Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.";

    public final static String bytes_ljust_doc = 
        "B.ljust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B left justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytes_lower_doc = 
        "B.lower() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to lowercase.";

    public final static String bytes_lstrip_doc = 
        "Strip leading bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading  ASCII whitespace.";

    public final static String bytes_maketrans_doc = 
        "Return a translation table useable for the bytes or bytearray translate method.\n" + 
        "\n" + 
        "The returned table will be one where each byte in frm is mapped to the byte at\n" + 
        "the same position in to.\n" + 
        "\n" + 
        "The bytes objects frm and to must be of the same length.";

    public final static String bytes_partition_doc = 
        "Partition the bytes into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytes. If the separator is found,\n" + 
        "returns a 3-tuple containing the part before the separator, the separator\n" + 
        "itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing the original bytes\n" + 
        "object and two empty bytes objects.";

    public final static String bytes_replace_doc = 
        "Return a copy with all occurrences of substring old replaced by new.\n" + 
        "\n" + 
        "  count\n" + 
        "    Maximum number of occurrences to replace.\n" + 
        "    -1 (the default value) means replace all occurrences.\n" + 
        "\n" + 
        "If the optional argument count is given, only the first count occurrences are\n" + 
        "replaced.";

    public final static String bytes_rfind_doc = 
        "B.rfind(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where substring sub is found,\n" + 
        "such that sub is contained within B[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytes_rindex_doc = 
        "B.rindex(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Like B.rfind() but raise ValueError when the substring is not found.";

    public final static String bytes_rjust_doc = 
        "B.rjust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B right justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String bytes_rpartition_doc = 
        "Partition the bytes into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytes, starting and the end. If\n" + 
        "the separator is found, returns a 3-tuple containing the part before the\n" + 
        "separator, the separator itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing two empty bytes\n" + 
        "objects and the original bytes object.";

    public final static String bytes_rsplit_doc = 
        "Return a list of the sections in the bytes, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytes.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.\n" + 
        "\n" + 
        "Splitting is done starting at the end of the bytes and working to the front.";

    public final static String bytes_rstrip_doc = 
        "Strip trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip trailing ASCII whitespace.";

    public final static String bytes_split_doc = 
        "Return a list of the sections in the bytes, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytes.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.";

    public final static String bytes_splitlines_doc = 
        "Return a list of the lines in the bytes, breaking at line boundaries.\n" + 
        "\n" + 
        "Line breaks are not included in the resulting list unless keepends is given and\n" + 
        "true.";

    public final static String bytes_startswith_doc = 
        "B.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "prefix can also be a tuple of bytes to try.";

    public final static String bytes_strip_doc = 
        "Strip leading and trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading and trailing ASCII whitespace.";

    public final static String bytes_swapcase_doc = 
        "B.swapcase() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with uppercase ASCII characters converted\n" + 
        "to lowercase ASCII and vice versa.";

    public final static String bytes_title_doc = 
        "B.title() -> copy of B\n" + 
        "\n" + 
        "Return a titlecased version of B, i.e. ASCII words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String bytes_translate_doc = 
        "translate(table, [deletechars])\n" + 
        "Return a copy with each character mapped by the given translation table.\n" + 
        "\n" + 
        "  table\n" + 
        "    Translation table, which must be a bytes object of length 256.\n" + 
        "\n" + 
        "All characters occurring in the optional argument deletechars are removed.\n" + 
        "The remaining characters are mapped through the given translation table.";

    public final static String bytes_upper_doc = 
        "B.upper() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to uppercase.";

    public final static String bytes_zfill_doc = 
        "B.zfill(width) -> copy of B\n" + 
        "\n" + 
        "Pad a numeric string B with zeros on the left, to fill a field\n" + 
        "of the specified width.  B is never truncated.";

    // Docs for <class 'dict'>
    public final static String dict___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String dict___contains___doc = 
        "True if D has a key k, else False.";

    public final static String dict___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String dict___delitem___doc = 
        "Delete self[key].";

    public final static String dict___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String dict_doc = 
        "dict() -> new empty dictionary\n" + 
        "dict(mapping) -> new dictionary initialized from a mapping object's\n" + 
        "    (key, value) pairs\n" + 
        "dict(iterable) -> new dictionary initialized as if via:\n" + 
        "    d = {}\n" + 
        "    for k, v in iterable:\n" + 
        "        d[k] = v\n" + 
        "dict(**kwargs) -> new dictionary initialized with the name=value pairs\n" + 
        "    in the keyword argument list.  For example:  dict(one=1, two=2)";

    public final static String dict___eq___doc = 
        "Return self==value.";

    public final static String dict___format___doc = 
        "default object formatter";

    public final static String dict___ge___doc = 
        "Return self>=value.";

    public final static String dict___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String dict___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String dict___gt___doc = 
        "Return self>value.";

    public final static String dict___hash___doc = 
        "";

    public final static String dict___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String dict___iter___doc = 
        "Implement iter(self).";

    public final static String dict___le___doc = 
        "Return self<=value.";

    public final static String dict___len___doc = 
        "Return len(self).";

    public final static String dict___lt___doc = 
        "Return self<value.";

    public final static String dict___ne___doc = 
        "Return self!=value.";

    public final static String dict___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String dict___reduce___doc = 
        "helper for pickle";

    public final static String dict___reduce_ex___doc = 
        "helper for pickle";

    public final static String dict___repr___doc = 
        "Return repr(self).";

    public final static String dict___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String dict___setitem___doc = 
        "Set self[key] to value.";

    public final static String dict___sizeof___doc = 
        "D.__sizeof__() -> size of D in memory, in bytes";

    public final static String dict___str___doc = 
        "Return str(self).";

    public final static String dict___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String dict_clear_doc = 
        "D.clear() -> None.  Remove all items from D.";

    public final static String dict_copy_doc = 
        "D.copy() -> a shallow copy of D";

    public final static String dict_fromkeys_doc = 
        "Returns a new dict with keys from iterable and values equal to value.";

    public final static String dict_get_doc = 
        "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.";

    public final static String dict_items_doc = 
        "D.items() -> a set-like object providing a view on D's items";

    public final static String dict_keys_doc = 
        "D.keys() -> a set-like object providing a view on D's keys";

    public final static String dict_pop_doc = 
        "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n" + 
        "If key is not found, d is returned if given, otherwise KeyError is raised";

    public final static String dict_popitem_doc = 
        "D.popitem() -> (k, v), remove and return some (key, value) pair as a\n" + 
        "2-tuple; but raise KeyError if D is empty.";

    public final static String dict_setdefault_doc = 
        "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D";

    public final static String dict_update_doc = 
        "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\n" + 
        "If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\n" + 
        "If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n" + 
        "In either case, this is followed by: for k in F:  D[k] = F[k]";

    public final static String dict_values_doc = 
        "D.values() -> an object providing a view on D's values";

    // Docs for <class 'list'>
    public final static String list___add___doc = 
        "Return self+value.";

    public final static String list___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String list___contains___doc = 
        "Return key in self.";

    public final static String list___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String list___delitem___doc = 
        "Delete self[key].";

    public final static String list___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String list_doc = 
        "list() -> new empty list\n" + 
        "list(iterable) -> new list initialized from iterable's items";

    public final static String list___eq___doc = 
        "Return self==value.";

    public final static String list___format___doc = 
        "default object formatter";

    public final static String list___ge___doc = 
        "Return self>=value.";

    public final static String list___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String list___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String list___gt___doc = 
        "Return self>value.";

    public final static String list___hash___doc = 
        "";

    public final static String list___iadd___doc = 
        "Implement self+=value.";

    public final static String list___imul___doc = 
        "Implement self*=value.";

    public final static String list___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String list___iter___doc = 
        "Implement iter(self).";

    public final static String list___le___doc = 
        "Return self<=value.";

    public final static String list___len___doc = 
        "Return len(self).";

    public final static String list___lt___doc = 
        "Return self<value.";

    public final static String list___mul___doc = 
        "Return self*value.n";

    public final static String list___ne___doc = 
        "Return self!=value.";

    public final static String list___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String list___reduce___doc = 
        "helper for pickle";

    public final static String list___reduce_ex___doc = 
        "helper for pickle";

    public final static String list___repr___doc = 
        "Return repr(self).";

    public final static String list___reversed___doc = 
        "L.__reversed__() -- return a reverse iterator over the list";

    public final static String list___rmul___doc = 
        "Return self*value.";

    public final static String list___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String list___setitem___doc = 
        "Set self[key] to value.";

    public final static String list___sizeof___doc = 
        "L.__sizeof__() -- size of L in memory, in bytes";

    public final static String list___str___doc = 
        "Return str(self).";

    public final static String list___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String list_append_doc = 
        "L.append(object) -> None -- append object to end";

    public final static String list_clear_doc = 
        "L.clear() -> None -- remove all items from L";

    public final static String list_copy_doc = 
        "L.copy() -> list -- a shallow copy of L";

    public final static String list_count_doc = 
        "L.count(value) -> integer -- return number of occurrences of value";

    public final static String list_extend_doc = 
        "L.extend(iterable) -> None -- extend list by appending elements from the iterable";

    public final static String list_index_doc = 
        "L.index(value, [start, [stop]]) -> integer -- return first index of value.\n" + 
        "Raises ValueError if the value is not present.";

    public final static String list_insert_doc = 
        "L.insert(index, object) -- insert object before index";

    public final static String list_pop_doc = 
        "L.pop([index]) -> item -- remove and return item at index (default last).\n" + 
        "Raises IndexError if list is empty or index is out of range.";

    public final static String list_remove_doc = 
        "L.remove(value) -> None -- remove first occurrence of value.\n" + 
        "Raises ValueError if the value is not present.";

    public final static String list_reverse_doc = 
        "L.reverse() -- reverse *IN PLACE*";

    public final static String list_sort_doc = 
        "L.sort(key=None, reverse=False) -> None -- stable sort *IN PLACE*";

    // Docs for <class 'slice'>
    public final static String slice___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String slice___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String slice___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String slice_doc = 
        "slice(stop)\n" + 
        "slice(start, stop[, step])\n" + 
        "\n" + 
        "Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).";

    public final static String slice___eq___doc = 
        "Return self==value.";

    public final static String slice___format___doc = 
        "default object formatter";

    public final static String slice___ge___doc = 
        "Return self>=value.";

    public final static String slice___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String slice___gt___doc = 
        "Return self>value.";

    public final static String slice___hash___doc = 
        "";

    public final static String slice___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String slice___le___doc = 
        "Return self<=value.";

    public final static String slice___lt___doc = 
        "Return self<value.";

    public final static String slice___ne___doc = 
        "Return self!=value.";

    public final static String slice___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String slice___reduce___doc = 
        "Return state information for pickling.";

    public final static String slice___reduce_ex___doc = 
        "helper for pickle";

    public final static String slice___repr___doc = 
        "Return repr(self).";

    public final static String slice___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String slice___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String slice___str___doc = 
        "Return str(self).";

    public final static String slice___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String slice_indices_doc = 
        "S.indices(len) -> (start, stop, stride)\n" + 
        "\n" + 
        "Assuming a sequence of length len, calculate the start and stop\n" + 
        "indices, and the stride length of the extended slice described by\n" + 
        "S. Out of bounds indices are clipped in a manner consistent with the\n" + 
        "handling of normal slices.";

    public final static String slice_start_doc = 
        "";

    public final static String slice_step_doc = 
        "";

    public final static String slice_stop_doc = 
        "";

    // Docs for <class 'super'>
    public final static String super___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String super___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String super___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String super_doc = 
        "super() -> same as super(__class__, <first argument>)\n" + 
        "super(type) -> unbound super object\n" + 
        "super(type, obj) -> bound super object; requires isinstance(obj, type)\n" + 
        "super(type, type2) -> bound super object; requires issubclass(type2, type)\n" + 
        "Typical use to call a cooperative superclass method:\n" + 
        "class C(B):\n" + 
        "    def meth(self, arg):\n" + 
        "        super().meth(arg)\n" + 
        "This works for class methods too:\n" + 
        "class C(B):\n" + 
        "    @classmethod\n" + 
        "    def cmeth(cls, arg):\n" + 
        "        super().cmeth(arg)\n" + 
        "";

    public final static String super___eq___doc = 
        "Return self==value.";

    public final static String super___format___doc = 
        "default object formatter";

    public final static String super___ge___doc = 
        "Return self>=value.";

    public final static String super___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String super___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String super___gt___doc = 
        "Return self>value.";

    public final static String super___hash___doc = 
        "Return hash(self).";

    public final static String super___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String super___le___doc = 
        "Return self<=value.";

    public final static String super___lt___doc = 
        "Return self<value.";

    public final static String super___ne___doc = 
        "Return self!=value.";

    public final static String super___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String super___reduce___doc = 
        "helper for pickle";

    public final static String super___reduce_ex___doc = 
        "helper for pickle";

    public final static String super___repr___doc = 
        "Return repr(self).";

    public final static String super___self___doc = 
        "the instance invoking super(); may be None";

    public final static String super___self_class___doc = 
        "the type of the instance invoking super(); may be None";

    public final static String super___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String super___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String super___str___doc = 
        "Return str(self).";

    public final static String super___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String super___thisclass___doc = 
        "the class invoking super()";

    // Docs for <class 'staticmethod'>
    public final static String staticmethod___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String staticmethod___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String staticmethod___dict___doc = 
        "";

    public final static String staticmethod___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String staticmethod_doc = 
        "staticmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a static method.\n" + 
        "\n" + 
        "A static method does not receive an implicit first argument.\n" + 
        "To declare a static method, use this idiom:\n" + 
        "\n" + 
        "     class C:\n" + 
        "     def f(arg1, arg2, ...): ...\n" + 
        "     f = staticmethod(f)\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "\n" + 
        "Static methods in Python are similar to those found in Java or C++.\n" + 
        "For a more advanced concept, see the classmethod builtin.";

    public final static String staticmethod___eq___doc = 
        "Return self==value.";

    public final static String staticmethod___format___doc = 
        "default object formatter";

    public final static String staticmethod___func___doc = 
        "";

    public final static String staticmethod___ge___doc = 
        "Return self>=value.";

    public final static String staticmethod___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String staticmethod___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String staticmethod___gt___doc = 
        "Return self>value.";

    public final static String staticmethod___hash___doc = 
        "Return hash(self).";

    public final static String staticmethod___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String staticmethod___isabstractmethod___doc = 
        "";

    public final static String staticmethod___le___doc = 
        "Return self<=value.";

    public final static String staticmethod___lt___doc = 
        "Return self<value.";

    public final static String staticmethod___ne___doc = 
        "Return self!=value.";

    public final static String staticmethod___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String staticmethod___reduce___doc = 
        "helper for pickle";

    public final static String staticmethod___reduce_ex___doc = 
        "helper for pickle";

    public final static String staticmethod___repr___doc = 
        "Return repr(self).";

    public final static String staticmethod___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String staticmethod___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String staticmethod___str___doc = 
        "Return str(self).";

    public final static String staticmethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'float'>
    public final static String float___abs___doc = 
        "abs(self)";

    public final static String float___add___doc = 
        "Return self+value.";

    public final static String float___bool___doc = 
        "self != 0";

    public final static String float___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String float___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String float___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String float___divmod___doc = 
        "Return divmod(self, value).";

    public final static String float_doc = 
        "float(x) -> floating point number\n" + 
        "\n" + 
        "Convert a string or number to a floating point number, if possible.";

    public final static String float___eq___doc = 
        "Return self==value.";

    public final static String float___float___doc = 
        "float(self)";

    public final static String float___floordiv___doc = 
        "Return self//value.";

    public final static String float___format___doc = 
        "float.__format__(format_spec) -> string\n" + 
        "\n" + 
        "Formats the float according to format_spec.";

    public final static String float___ge___doc = 
        "Return self>=value.";

    public final static String float___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String float___getformat___doc = 
        "float.__getformat__(typestr) -> string\n" + 
        "\n" + 
        "You probably don't want to use this function.  It exists mainly to be\n" + 
        "used in Python's test suite.\n" + 
        "\n" + 
        "typestr must be 'double' or 'float'.  This function returns whichever of\n" + 
        "'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the\n" + 
        "format of floating point numbers used by the C type named by typestr.";

    public final static String float___getnewargs___doc = 
        "";

    public final static String float___gt___doc = 
        "Return self>value.";

    public final static String float___hash___doc = 
        "Return hash(self).";

    public final static String float___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String float___int___doc = 
        "int(self)";

    public final static String float___le___doc = 
        "Return self<=value.";

    public final static String float___lt___doc = 
        "Return self<value.";

    public final static String float___mod___doc = 
        "Return self%value.";

    public final static String float___mul___doc = 
        "Return self*value.";

    public final static String float___ne___doc = 
        "Return self!=value.";

    public final static String float___neg___doc = 
        "-self";

    public final static String float___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String float___pos___doc = 
        "+self";

    public final static String float___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String float___radd___doc = 
        "Return value+self.";

    public final static String float___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String float___reduce___doc = 
        "helper for pickle";

    public final static String float___reduce_ex___doc = 
        "helper for pickle";

    public final static String float___repr___doc = 
        "Return repr(self).";

    public final static String float___rfloordiv___doc = 
        "Return value//self.";

    public final static String float___rmod___doc = 
        "Return value%self.";

    public final static String float___rmul___doc = 
        "Return value*self.";

    public final static String float___round___doc = 
        "Return the Integral closest to x, rounding half toward even.\n" + 
        "When an argument is passed, work like built-in round(x, ndigits).";

    public final static String float___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String float___rsub___doc = 
        "Return value-self.";

    public final static String float___rtruediv___doc = 
        "Return value/self.";

    public final static String float___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String float___setformat___doc = 
        "float.__setformat__(typestr, fmt) -> None\n" + 
        "\n" + 
        "You probably don't want to use this function.  It exists mainly to be\n" + 
        "used in Python's test suite.\n" + 
        "\n" + 
        "typestr must be 'double' or 'float'.  fmt must be one of 'unknown',\n" + 
        "'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be\n" + 
        "one of the latter two if it appears to match the underlying C reality.\n" + 
        "\n" + 
        "Override the automatic determination of C-level floating point type.\n" + 
        "This affects how floats are converted to and from binary strings.";

    public final static String float___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String float___str___doc = 
        "Return str(self).";

    public final static String float___sub___doc = 
        "Return self-value.";

    public final static String float___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String float___truediv___doc = 
        "Return self/value.";

    public final static String float___trunc___doc = 
        "Return the Integral closest to x between 0 and x.";

    public final static String float_as_integer_ratio_doc = 
        "float.as_integer_ratio() -> (int, int)\n" + 
        "\n" + 
        "Return a pair of integers, whose ratio is exactly equal to the original\n" + 
        "float and with a positive denominator.\n" + 
        "Raise OverflowError on infinities and a ValueError on NaNs.\n" + 
        "\n" + 
        ">>> (10.0).as_integer_ratio()\n" + 
        "(10, 1)\n" + 
        ">>> (0.0).as_integer_ratio()\n" + 
        "(0, 1)\n" + 
        ">>> (-.25).as_integer_ratio()\n" + 
        "(-1, 4)";

    public final static String float_conjugate_doc = 
        "Return self, the complex conjugate of any float.";

    public final static String float_fromhex_doc = 
        "float.fromhex(string) -> float\n" + 
        "\n" + 
        "Create a floating-point number from a hexadecimal string.\n" + 
        ">>> float.fromhex('0x1.ffffp10')\n" + 
        "2047.984375\n" + 
        ">>> float.fromhex('-0x1p-1074')\n" + 
        "-5e-324";

    public final static String float_hex_doc = 
        "float.hex() -> string\n" + 
        "\n" + 
        "Return a hexadecimal representation of a floating-point number.\n" + 
        ">>> (-0.1).hex()\n" + 
        "'-0x1.999999999999ap-4'\n" + 
        ">>> 3.14159.hex()\n" + 
        "'0x1.921f9f01b866ep+1'";

    public final static String float_imag_doc = 
        "the imaginary part of a complex number";

    public final static String float_is_integer_doc = 
        "Return True if the float is an integer.";

    public final static String float_real_doc = 
        "the real part of a complex number";

    // Docs for <class 'enumerate'>
    public final static String enumerate___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String enumerate___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String enumerate___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String enumerate_doc = 
        "enumerate(iterable[, start]) -> iterator for index, value of iterable\n" + 
        "\n" + 
        "Return an enumerate object.  iterable must be another object that supports\n" + 
        "iteration.  The enumerate object yields pairs containing a count (from\n" + 
        "start, which defaults to zero) and a value yielded by the iterable argument.\n" + 
        "enumerate is useful for obtaining an indexed list:\n" + 
        "    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...";

    public final static String enumerate___eq___doc = 
        "Return self==value.";

    public final static String enumerate___format___doc = 
        "default object formatter";

    public final static String enumerate___ge___doc = 
        "Return self>=value.";

    public final static String enumerate___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String enumerate___gt___doc = 
        "Return self>value.";

    public final static String enumerate___hash___doc = 
        "Return hash(self).";

    public final static String enumerate___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String enumerate___iter___doc = 
        "Implement iter(self).";

    public final static String enumerate___le___doc = 
        "Return self<=value.";

    public final static String enumerate___lt___doc = 
        "Return self<value.";

    public final static String enumerate___ne___doc = 
        "Return self!=value.";

    public final static String enumerate___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String enumerate___next___doc = 
        "Implement next(self).";

    public final static String enumerate___reduce___doc = 
        "Return state information for pickling.";

    public final static String enumerate___reduce_ex___doc = 
        "helper for pickle";

    public final static String enumerate___repr___doc = 
        "Return repr(self).";

    public final static String enumerate___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String enumerate___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String enumerate___str___doc = 
        "Return str(self).";

    public final static String enumerate___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'int'>
    public final static String int___abs___doc = 
        "abs(self)";

    public final static String int___add___doc = 
        "Return self+value.";

    public final static String int___and___doc = 
        "Return self&value.";

    public final static String int___bool___doc = 
        "self != 0";

    public final static String int___ceil___doc = 
        "Ceiling of an Integral returns itself.";

    public final static String int___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String int___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String int___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String int___divmod___doc = 
        "Return divmod(self, value).";

    public final static String int_doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String int___eq___doc = 
        "Return self==value.";

    public final static String int___float___doc = 
        "float(self)";

    public final static String int___floor___doc = 
        "Flooring an Integral returns itself.";

    public final static String int___floordiv___doc = 
        "Return self//value.";

    public final static String int___format___doc = 
        "";

    public final static String int___ge___doc = 
        "Return self>=value.";

    public final static String int___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String int___getnewargs___doc = 
        "";

    public final static String int___gt___doc = 
        "Return self>value.";

    public final static String int___hash___doc = 
        "Return hash(self).";

    public final static String int___index___doc = 
        "Return self converted to an integer, if self is suitable for use as an index into a list.";

    public final static String int___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String int___int___doc = 
        "int(self)";

    public final static String int___invert___doc = 
        "~self";

    public final static String int___le___doc = 
        "Return self<=value.";

    public final static String int___lshift___doc = 
        "Return self<<value.";

    public final static String int___lt___doc = 
        "Return self<value.";

    public final static String int___mod___doc = 
        "Return self%value.";

    public final static String int___mul___doc = 
        "Return self*value.";

    public final static String int___ne___doc = 
        "Return self!=value.";

    public final static String int___neg___doc = 
        "-self";

    public final static String int___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String int___or___doc = 
        "Return self|value.";

    public final static String int___pos___doc = 
        "+self";

    public final static String int___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String int___radd___doc = 
        "Return value+self.";

    public final static String int___rand___doc = 
        "Return value&self.";

    public final static String int___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String int___reduce___doc = 
        "helper for pickle";

    public final static String int___reduce_ex___doc = 
        "helper for pickle";

    public final static String int___repr___doc = 
        "Return repr(self).";

    public final static String int___rfloordiv___doc = 
        "Return value//self.";

    public final static String int___rlshift___doc = 
        "Return value<<self.";

    public final static String int___rmod___doc = 
        "Return value%self.";

    public final static String int___rmul___doc = 
        "Return value*self.";

    public final static String int___ror___doc = 
        "Return value|self.";

    public final static String int___round___doc = 
        "Rounding an Integral returns itself.\n" + 
        "Rounding with an ndigits argument also returns an integer.";

    public final static String int___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String int___rrshift___doc = 
        "Return value>>self.";

    public final static String int___rshift___doc = 
        "Return self>>value.";

    public final static String int___rsub___doc = 
        "Return value-self.";

    public final static String int___rtruediv___doc = 
        "Return value/self.";

    public final static String int___rxor___doc = 
        "Return value^self.";

    public final static String int___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String int___sizeof___doc = 
        "Returns size in memory, in bytes";

    public final static String int___str___doc = 
        "Return str(self).";

    public final static String int___sub___doc = 
        "Return self-value.";

    public final static String int___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String int___truediv___doc = 
        "Return self/value.";

    public final static String int___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String int___xor___doc = 
        "Return self^value.";

    public final static String int_bit_length_doc = 
        "int.bit_length() -> int\n" + 
        "\n" + 
        "Number of bits necessary to represent self in binary.\n" + 
        ">>> bin(37)\n" + 
        "'0b100101'\n" + 
        ">>> (37).bit_length()\n" + 
        "6";

    public final static String int_conjugate_doc = 
        "Returns self, the complex conjugate of any int.";

    public final static String int_denominator_doc = 
        "the denominator of a rational number in lowest terms";

    public final static String int_from_bytes_doc = 
        "int.from_bytes(bytes, byteorder, *, signed=False) -> int\n" + 
        "\n" + 
        "Return the integer represented by the given array of bytes.\n" + 
        "\n" + 
        "The bytes argument must be a bytes-like object (e.g. bytes or bytearray).\n" + 
        "\n" + 
        "The byteorder argument determines the byte order used to represent the\n" + 
        "integer.  If byteorder is 'big', the most significant byte is at the\n" + 
        "beginning of the byte array.  If byteorder is 'little', the most\n" + 
        "significant byte is at the end of the byte array.  To request the native\n" + 
        "byte order of the host system, use `sys.byteorder' as the byte order value.\n" + 
        "\n" + 
        "The signed keyword-only argument indicates whether two's complement is\n" + 
        "used to represent the integer.";

    public final static String int_imag_doc = 
        "the imaginary part of a complex number";

    public final static String int_numerator_doc = 
        "the numerator of a rational number in lowest terms";

    public final static String int_real_doc = 
        "the real part of a complex number";

    public final static String int_to_bytes_doc = 
        "int.to_bytes(length, byteorder, *, signed=False) -> bytes\n" + 
        "\n" + 
        "Return an array of bytes representing an integer.\n" + 
        "\n" + 
        "The integer is represented using length bytes.  An OverflowError is\n" + 
        "raised if the integer is not representable with the given number of\n" + 
        "bytes.\n" + 
        "\n" + 
        "The byteorder argument determines the byte order used to represent the\n" + 
        "integer.  If byteorder is 'big', the most significant byte is at the\n" + 
        "beginning of the byte array.  If byteorder is 'little', the most\n" + 
        "significant byte is at the end of the byte array.  To request the native\n" + 
        "byte order of the host system, use `sys.byteorder' as the byte order value.\n" + 
        "\n" + 
        "The signed keyword-only argument determines whether two's complement is\n" + 
        "used to represent the integer.  If signed is False and a negative integer\n" + 
        "is given, an OverflowError is raised.";

    // Docs for <class 'tuple'>
    public final static String tuple___add___doc = 
        "Return self+value.";

    public final static String tuple___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String tuple___contains___doc = 
        "Return key in self.";

    public final static String tuple___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String tuple___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String tuple_doc = 
        "tuple() -> empty tuple\n" + 
        "tuple(iterable) -> tuple initialized from iterable's items\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String tuple___eq___doc = 
        "Return self==value.";

    public final static String tuple___format___doc = 
        "default object formatter";

    public final static String tuple___ge___doc = 
        "Return self>=value.";

    public final static String tuple___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String tuple___getitem___doc = 
        "Return self[key].";

    public final static String tuple___getnewargs___doc = 
        "";

    public final static String tuple___gt___doc = 
        "Return self>value.";

    public final static String tuple___hash___doc = 
        "Return hash(self).";

    public final static String tuple___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String tuple___iter___doc = 
        "Implement iter(self).";

    public final static String tuple___le___doc = 
        "Return self<=value.";

    public final static String tuple___len___doc = 
        "Return len(self).";

    public final static String tuple___lt___doc = 
        "Return self<value.";

    public final static String tuple___mul___doc = 
        "Return self*value.n";

    public final static String tuple___ne___doc = 
        "Return self!=value.";

    public final static String tuple___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String tuple___reduce___doc = 
        "helper for pickle";

    public final static String tuple___reduce_ex___doc = 
        "helper for pickle";

    public final static String tuple___repr___doc = 
        "Return repr(self).";

    public final static String tuple___rmul___doc = 
        "Return self*value.";

    public final static String tuple___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String tuple___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String tuple___str___doc = 
        "Return str(self).";

    public final static String tuple___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String tuple_count_doc = 
        "T.count(value) -> integer -- return number of occurrences of value";

    public final static String tuple_index_doc = 
        "T.index(value, [start, [stop]]) -> integer -- return first index of value.\n" + 
        "Raises ValueError if the value is not present.";

    // Docs for <class 'str'>
    public final static String str___add___doc = 
        "Return self+value.";

    public final static String str___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String str___contains___doc = 
        "Return key in self.";

    public final static String str___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String str___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String str_doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String str___eq___doc = 
        "Return self==value.";

    public final static String str___format___doc = 
        "S.__format__(format_spec) -> str\n" + 
        "\n" + 
        "Return a formatted version of S as described by format_spec.";

    public final static String str___ge___doc = 
        "Return self>=value.";

    public final static String str___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String str___getitem___doc = 
        "Return self[key].";

    public final static String str___getnewargs___doc = 
        "";

    public final static String str___gt___doc = 
        "Return self>value.";

    public final static String str___hash___doc = 
        "Return hash(self).";

    public final static String str___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String str___iter___doc = 
        "Implement iter(self).";

    public final static String str___le___doc = 
        "Return self<=value.";

    public final static String str___len___doc = 
        "Return len(self).";

    public final static String str___lt___doc = 
        "Return self<value.";

    public final static String str___mod___doc = 
        "Return self%value.";

    public final static String str___mul___doc = 
        "Return self*value.n";

    public final static String str___ne___doc = 
        "Return self!=value.";

    public final static String str___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String str___reduce___doc = 
        "helper for pickle";

    public final static String str___reduce_ex___doc = 
        "helper for pickle";

    public final static String str___repr___doc = 
        "Return repr(self).";

    public final static String str___rmod___doc = 
        "Return value%self.";

    public final static String str___rmul___doc = 
        "Return self*value.";

    public final static String str___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String str___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String str___str___doc = 
        "Return str(self).";

    public final static String str___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String str_capitalize_doc = 
        "S.capitalize() -> str\n" + 
        "\n" + 
        "Return a capitalized version of S, i.e. make the first character\n" + 
        "have upper case and the rest lower case.";

    public final static String str_casefold_doc = 
        "S.casefold() -> str\n" + 
        "\n" + 
        "Return a version of S suitable for caseless comparisons.";

    public final static String str_center_doc = 
        "S.center(width[, fillchar]) -> str\n" + 
        "\n" + 
        "Return S centered in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String str_count_doc = 
        "S.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "string S[start:end].  Optional arguments start and end are\n" + 
        "interpreted as in slice notation.";

    public final static String str_encode_doc = 
        "S.encode(encoding='utf-8', errors='strict') -> bytes\n" + 
        "\n" + 
        "Encode S using the codec registered for encoding. Default encoding\n" + 
        "is 'utf-8'. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n" + 
        "'xmlcharrefreplace' as well as any other name registered with\n" + 
        "codecs.register_error that can handle UnicodeEncodeErrors.";

    public final static String str_endswith_doc = 
        "S.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String str_expandtabs_doc = 
        "S.expandtabs(tabsize=8) -> str\n" + 
        "\n" + 
        "Return a copy of S where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String str_find_doc = 
        "S.find(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found,\n" + 
        "such that sub is contained within S[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_format_doc = 
        "S.format(*args, **kwargs) -> str\n" + 
        "\n" + 
        "Return a formatted version of S, using substitutions from args and kwargs.\n" + 
        "The substitutions are identified by braces ('{' and '}').";

    public final static String str_format_map_doc = 
        "S.format_map(mapping) -> str\n" + 
        "\n" + 
        "Return a formatted version of S, using substitutions from mapping.\n" + 
        "The substitutions are identified by braces ('{' and '}').";

    public final static String str_index_doc = 
        "S.index(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Like S.find() but raise ValueError when the substring is not found.";

    public final static String str_isalnum_doc = 
        "S.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphanumeric\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isalpha_doc = 
        "S.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphabetic\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isdecimal_doc = 
        "S.isdecimal() -> bool\n" + 
        "\n" + 
        "Return True if there are only decimal characters in S,\n" + 
        "False otherwise.";

    public final static String str_isdigit_doc = 
        "S.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are digits\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isidentifier_doc = 
        "S.isidentifier() -> bool\n" + 
        "\n" + 
        "Return True if S is a valid identifier according\n" + 
        "to the language definition.\n" + 
        "\n" + 
        "Use keyword.iskeyword() to test for reserved identifiers\n" + 
        "such as \"def\" and \"class\".\n" + 
        "";

    public final static String str_islower_doc = 
        "S.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are lowercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String str_isnumeric_doc = 
        "S.isnumeric() -> bool\n" + 
        "\n" + 
        "Return True if there are only numeric characters in S,\n" + 
        "False otherwise.";

    public final static String str_isprintable_doc = 
        "S.isprintable() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are considered\n" + 
        "printable in repr() or S is empty, False otherwise.";

    public final static String str_isspace_doc = 
        "S.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are whitespace\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_istitle_doc = 
        "S.istitle() -> bool\n" + 
        "\n" + 
        "Return True if S is a titlecased string and there is at least one\n" + 
        "character in S, i.e. upper- and titlecase characters may only\n" + 
        "follow uncased characters and lowercase characters only cased ones.\n" + 
        "Return False otherwise.";

    public final static String str_isupper_doc = 
        "S.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are uppercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String str_join_doc = 
        "S.join(iterable) -> str\n" + 
        "\n" + 
        "Return a string which is the concatenation of the strings in the\n" + 
        "iterable.  The separator between elements is S.";

    public final static String str_ljust_doc = 
        "S.ljust(width[, fillchar]) -> str\n" + 
        "\n" + 
        "Return S left-justified in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String str_lower_doc = 
        "S.lower() -> str\n" + 
        "\n" + 
        "Return a copy of the string S converted to lowercase.";

    public final static String str_lstrip_doc = 
        "S.lstrip([chars]) -> str\n" + 
        "\n" + 
        "Return a copy of the string S with leading whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.";

    public final static String str_maketrans_doc = 
        "Return a translation table usable for str.translate().\n" + 
        "\n" + 
        "If there is only one argument, it must be a dictionary mapping Unicode\n" + 
        "ordinals (integers) or characters to Unicode ordinals, strings or None.\n" + 
        "Character keys will be then converted to ordinals.\n" + 
        "If there are two arguments, they must be strings of equal length, and\n" + 
        "in the resulting dictionary, each character in x will be mapped to the\n" + 
        "character at the same position in y. If there is a third argument, it\n" + 
        "must be a string, whose characters will be mapped to None in the result.";

    public final static String str_partition_doc = 
        "S.partition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Search for the separator sep in S, and return the part before it,\n" + 
        "the separator itself, and the part after it.  If the separator is not\n" + 
        "found, return S and two empty strings.";

    public final static String str_replace_doc = 
        "S.replace(old, new[, count]) -> str\n" + 
        "\n" + 
        "Return a copy of S with all occurrences of substring\n" + 
        "old replaced by new.  If the optional argument count is\n" + 
        "given, only the first count occurrences are replaced.";

    public final static String str_rfind_doc = 
        "S.rfind(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within S[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_rindex_doc = 
        "S.rindex(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Like S.rfind() but raise ValueError when the substring is not found.";

    public final static String str_rjust_doc = 
        "S.rjust(width[, fillchar]) -> str\n" + 
        "\n" + 
        "Return S right-justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String str_rpartition_doc = 
        "S.rpartition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Search for the separator sep in S, starting at the end of S, and return\n" + 
        "the part before it, the separator itself, and the part after it.  If the\n" + 
        "separator is not found, return two empty strings and S.";

    public final static String str_rsplit_doc = 
        "S.rsplit(sep=None, maxsplit=-1) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in S, using sep as the\n" + 
        "delimiter string, starting at the end of the string and\n" + 
        "working to the front.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified, any whitespace string\n" + 
        "is a separator.";

    public final static String str_rstrip_doc = 
        "S.rstrip([chars]) -> str\n" + 
        "\n" + 
        "Return a copy of the string S with trailing whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.";

    public final static String str_split_doc = 
        "S.split(sep=None, maxsplit=-1) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in S, using sep as the\n" + 
        "delimiter string.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified or is None, any\n" + 
        "whitespace string is a separator and empty strings are\n" + 
        "removed from the result.";

    public final static String str_splitlines_doc = 
        "S.splitlines([keepends]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the lines in S, breaking at line boundaries.\n" + 
        "Line breaks are not included in the resulting list unless keepends\n" + 
        "is given and true.";

    public final static String str_startswith_doc = 
        "S.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String str_strip_doc = 
        "S.strip([chars]) -> str\n" + 
        "\n" + 
        "Return a copy of the string S with leading and trailing\n" + 
        "whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.";

    public final static String str_swapcase_doc = 
        "S.swapcase() -> str\n" + 
        "\n" + 
        "Return a copy of S with uppercase characters converted to lowercase\n" + 
        "and vice versa.";

    public final static String str_title_doc = 
        "S.title() -> str\n" + 
        "\n" + 
        "Return a titlecased version of S, i.e. words start with title case\n" + 
        "characters, all remaining cased characters have lower case.";

    public final static String str_translate_doc = 
        "S.translate(table) -> str\n" + 
        "\n" + 
        "Return a copy of the string S in which each character has been mapped\n" + 
        "through the given translation table. The table must implement\n" + 
        "lookup/indexing via __getitem__, for instance a dictionary or list,\n" + 
        "mapping Unicode ordinals to Unicode ordinals, strings, or None. If\n" + 
        "this operation raises LookupError, the character is left untouched.\n" + 
        "Characters mapped to None are deleted.";

    public final static String str_upper_doc = 
        "S.upper() -> str\n" + 
        "\n" + 
        "Return a copy of S converted to uppercase.";

    public final static String str_zfill_doc = 
        "S.zfill(width) -> str\n" + 
        "\n" + 
        "Pad a numeric string S with zeros on the left, to fill a field\n" + 
        "of the specified width. The string S is never truncated.";

    // Docs for <class 'property'>
    public final static String property___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String property___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String property___delete___doc = 
        "Delete an attribute of instance.";

    public final static String property___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String property_doc = 
        "property(fget=None, fset=None, fdel=None, doc=None) -> property attribute\n" + 
        "\n" + 
        "fget is a function to be used for getting an attribute value, and likewise\n" + 
        "fset is a function for setting, and fdel a function for del'ing, an\n" + 
        "attribute.  Typical use is to define a managed attribute x:\n" + 
        "\n" + 
        "class C(object):\n" + 
        "    def getx(self): return self._x\n" + 
        "    def setx(self, value): self._x = value\n" + 
        "    def delx(self): del self._x\n" + 
        "    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n" + 
        "\n" + 
        "Decorators make defining new properties or modifying existing ones easy:\n" + 
        "\n" + 
        "class C(object):\n" + 
        "    @property\n" + 
        "    def x(self):\n" + 
        "        \"I am the 'x' property.\"\n" + 
        "        return self._x\n" + 
        "    @x.setter\n" + 
        "    def x(self, value):\n" + 
        "        self._x = value\n" + 
        "    @x.deleter\n" + 
        "    def x(self):\n" + 
        "        del self._x\n" + 
        "";

    public final static String property___eq___doc = 
        "Return self==value.";

    public final static String property___format___doc = 
        "default object formatter";

    public final static String property___ge___doc = 
        "Return self>=value.";

    public final static String property___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String property___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String property___gt___doc = 
        "Return self>value.";

    public final static String property___hash___doc = 
        "Return hash(self).";

    public final static String property___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String property___isabstractmethod___doc = 
        "";

    public final static String property___le___doc = 
        "Return self<=value.";

    public final static String property___lt___doc = 
        "Return self<value.";

    public final static String property___ne___doc = 
        "Return self!=value.";

    public final static String property___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String property___reduce___doc = 
        "helper for pickle";

    public final static String property___reduce_ex___doc = 
        "helper for pickle";

    public final static String property___repr___doc = 
        "Return repr(self).";

    public final static String property___set___doc = 
        "Set an attribute of instance to value.";

    public final static String property___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String property___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String property___str___doc = 
        "Return str(self).";

    public final static String property___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String property_deleter_doc = 
        "Descriptor to change the deleter on a property.";

    public final static String property_fdel_doc = 
        "";

    public final static String property_fget_doc = 
        "";

    public final static String property_fset_doc = 
        "";

    public final static String property_getter_doc = 
        "Descriptor to change the getter on a property.";

    public final static String property_setter_doc = 
        "Descriptor to change the setter on a property.";

    // Docs for <class 'range'>
    public final static String range___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String range___contains___doc = 
        "Return key in self.";

    public final static String range___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String range___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String range_doc = 
        "range(stop) -> range object\n" + 
        "range(start, stop[, step]) -> range object\n" + 
        "\n" + 
        "Return an object that produces a sequence of integers from start (inclusive)\n" + 
        "to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\n" + 
        "start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\n" + 
        "These are exactly the valid indices for a list of 4 elements.\n" + 
        "When step is given, it specifies the increment (or decrement).";

    public final static String range___eq___doc = 
        "Return self==value.";

    public final static String range___format___doc = 
        "default object formatter";

    public final static String range___ge___doc = 
        "Return self>=value.";

    public final static String range___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String range___getitem___doc = 
        "Return self[key].";

    public final static String range___gt___doc = 
        "Return self>value.";

    public final static String range___hash___doc = 
        "Return hash(self).";

    public final static String range___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String range___iter___doc = 
        "Implement iter(self).";

    public final static String range___le___doc = 
        "Return self<=value.";

    public final static String range___len___doc = 
        "Return len(self).";

    public final static String range___lt___doc = 
        "Return self<value.";

    public final static String range___ne___doc = 
        "Return self!=value.";

    public final static String range___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String range___reduce___doc = 
        "";

    public final static String range___reduce_ex___doc = 
        "helper for pickle";

    public final static String range___repr___doc = 
        "Return repr(self).";

    public final static String range___reversed___doc = 
        "Return a reverse iterator.";

    public final static String range___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String range___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String range___str___doc = 
        "Return str(self).";

    public final static String range___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String range_count_doc = 
        "rangeobject.count(value) -> integer -- return number of occurrences of value";

    public final static String range_index_doc = 
        "rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.\n" + 
        "Raise ValueError if the value is not present.";

    public final static String range_start_doc = 
        "";

    public final static String range_step_doc = 
        "";

    public final static String range_stop_doc = 
        "";

    // Docs for <class 'complex'>
    public final static String complex___abs___doc = 
        "abs(self)";

    public final static String complex___add___doc = 
        "Return self+value.";

    public final static String complex___bool___doc = 
        "self != 0";

    public final static String complex___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String complex___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String complex___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String complex___divmod___doc = 
        "Return divmod(self, value).";

    public final static String complex_doc = 
        "complex(real[, imag]) -> complex number\n" + 
        "\n" + 
        "Create a complex number from a real part and an optional imaginary part.\n" + 
        "This is equivalent to (real + imag*1j) where imag defaults to 0.";

    public final static String complex___eq___doc = 
        "Return self==value.";

    public final static String complex___float___doc = 
        "float(self)";

    public final static String complex___floordiv___doc = 
        "Return self//value.";

    public final static String complex___format___doc = 
        "complex.__format__() -> str\n" + 
        "\n" + 
        "Convert to a string according to format_spec.";

    public final static String complex___ge___doc = 
        "Return self>=value.";

    public final static String complex___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String complex___getnewargs___doc = 
        "";

    public final static String complex___gt___doc = 
        "Return self>value.";

    public final static String complex___hash___doc = 
        "Return hash(self).";

    public final static String complex___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String complex___int___doc = 
        "int(self)";

    public final static String complex___le___doc = 
        "Return self<=value.";

    public final static String complex___lt___doc = 
        "Return self<value.";

    public final static String complex___mod___doc = 
        "Return self%value.";

    public final static String complex___mul___doc = 
        "Return self*value.";

    public final static String complex___ne___doc = 
        "Return self!=value.";

    public final static String complex___neg___doc = 
        "-self";

    public final static String complex___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String complex___pos___doc = 
        "+self";

    public final static String complex___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String complex___radd___doc = 
        "Return value+self.";

    public final static String complex___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String complex___reduce___doc = 
        "helper for pickle";

    public final static String complex___reduce_ex___doc = 
        "helper for pickle";

    public final static String complex___repr___doc = 
        "Return repr(self).";

    public final static String complex___rfloordiv___doc = 
        "Return value//self.";

    public final static String complex___rmod___doc = 
        "Return value%self.";

    public final static String complex___rmul___doc = 
        "Return value*self.";

    public final static String complex___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String complex___rsub___doc = 
        "Return value-self.";

    public final static String complex___rtruediv___doc = 
        "Return value/self.";

    public final static String complex___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String complex___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String complex___str___doc = 
        "Return str(self).";

    public final static String complex___sub___doc = 
        "Return self-value.";

    public final static String complex___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String complex___truediv___doc = 
        "Return self/value.";

    public final static String complex_conjugate_doc = 
        "complex.conjugate() -> complex\n" + 
        "\n" + 
        "Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.";

    public final static String complex_imag_doc = 
        "the imaginary part of a complex number";

    public final static String complex_real_doc = 
        "the real part of a complex number";

    // Docs for <class 'bool'>
    public final static String bool___abs___doc = 
        "abs(self)";

    public final static String bool___add___doc = 
        "Return self+value.";

    public final static String bool___and___doc = 
        "Return self&value.";

    public final static String bool___bool___doc = 
        "self != 0";

    public final static String bool___ceil___doc = 
        "Ceiling of an Integral returns itself.";

    public final static String bool___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bool___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String bool___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String bool___divmod___doc = 
        "Return divmod(self, value).";

    public final static String bool_doc = 
        "bool(x) -> bool\n" + 
        "\n" + 
        "Returns True when the argument x is true, False otherwise.\n" + 
        "The builtins True and False are the only two instances of the class bool.\n" + 
        "The class bool is a subclass of the class int, and cannot be subclassed.";

    public final static String bool___eq___doc = 
        "Return self==value.";

    public final static String bool___float___doc = 
        "float(self)";

    public final static String bool___floor___doc = 
        "Flooring an Integral returns itself.";

    public final static String bool___floordiv___doc = 
        "Return self//value.";

    public final static String bool___format___doc = 
        "";

    public final static String bool___ge___doc = 
        "Return self>=value.";

    public final static String bool___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String bool___getnewargs___doc = 
        "";

    public final static String bool___gt___doc = 
        "Return self>value.";

    public final static String bool___hash___doc = 
        "Return hash(self).";

    public final static String bool___index___doc = 
        "Return self converted to an integer, if self is suitable for use as an index into a list.";

    public final static String bool___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String bool___int___doc = 
        "int(self)";

    public final static String bool___invert___doc = 
        "~self";

    public final static String bool___le___doc = 
        "Return self<=value.";

    public final static String bool___lshift___doc = 
        "Return self<<value.";

    public final static String bool___lt___doc = 
        "Return self<value.";

    public final static String bool___mod___doc = 
        "Return self%value.";

    public final static String bool___mul___doc = 
        "Return self*value.";

    public final static String bool___ne___doc = 
        "Return self!=value.";

    public final static String bool___neg___doc = 
        "-self";

    public final static String bool___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String bool___or___doc = 
        "Return self|value.";

    public final static String bool___pos___doc = 
        "+self";

    public final static String bool___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String bool___radd___doc = 
        "Return value+self.";

    public final static String bool___rand___doc = 
        "Return value&self.";

    public final static String bool___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String bool___reduce___doc = 
        "helper for pickle";

    public final static String bool___reduce_ex___doc = 
        "helper for pickle";

    public final static String bool___repr___doc = 
        "Return repr(self).";

    public final static String bool___rfloordiv___doc = 
        "Return value//self.";

    public final static String bool___rlshift___doc = 
        "Return value<<self.";

    public final static String bool___rmod___doc = 
        "Return value%self.";

    public final static String bool___rmul___doc = 
        "Return value*self.";

    public final static String bool___ror___doc = 
        "Return value|self.";

    public final static String bool___round___doc = 
        "Rounding an Integral returns itself.\n" + 
        "Rounding with an ndigits argument also returns an integer.";

    public final static String bool___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String bool___rrshift___doc = 
        "Return value>>self.";

    public final static String bool___rshift___doc = 
        "Return self>>value.";

    public final static String bool___rsub___doc = 
        "Return value-self.";

    public final static String bool___rtruediv___doc = 
        "Return value/self.";

    public final static String bool___rxor___doc = 
        "Return value^self.";

    public final static String bool___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String bool___sizeof___doc = 
        "Returns size in memory, in bytes";

    public final static String bool___str___doc = 
        "Return str(self).";

    public final static String bool___sub___doc = 
        "Return self-value.";

    public final static String bool___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bool___truediv___doc = 
        "Return self/value.";

    public final static String bool___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String bool___xor___doc = 
        "Return self^value.";

    public final static String bool_bit_length_doc = 
        "int.bit_length() -> int\n" + 
        "\n" + 
        "Number of bits necessary to represent self in binary.\n" + 
        ">>> bin(37)\n" + 
        "'0b100101'\n" + 
        ">>> (37).bit_length()\n" + 
        "6";

    public final static String bool_conjugate_doc = 
        "Returns self, the complex conjugate of any int.";

    public final static String bool_denominator_doc = 
        "the denominator of a rational number in lowest terms";

    public final static String bool_from_bytes_doc = 
        "int.from_bytes(bytes, byteorder, *, signed=False) -> int\n" + 
        "\n" + 
        "Return the integer represented by the given array of bytes.\n" + 
        "\n" + 
        "The bytes argument must be a bytes-like object (e.g. bytes or bytearray).\n" + 
        "\n" + 
        "The byteorder argument determines the byte order used to represent the\n" + 
        "integer.  If byteorder is 'big', the most significant byte is at the\n" + 
        "beginning of the byte array.  If byteorder is 'little', the most\n" + 
        "significant byte is at the end of the byte array.  To request the native\n" + 
        "byte order of the host system, use `sys.byteorder' as the byte order value.\n" + 
        "\n" + 
        "The signed keyword-only argument indicates whether two's complement is\n" + 
        "used to represent the integer.";

    public final static String bool_imag_doc = 
        "the imaginary part of a complex number";

    public final static String bool_numerator_doc = 
        "the numerator of a rational number in lowest terms";

    public final static String bool_real_doc = 
        "the real part of a complex number";

    public final static String bool_to_bytes_doc = 
        "int.to_bytes(length, byteorder, *, signed=False) -> bytes\n" + 
        "\n" + 
        "Return an array of bytes representing an integer.\n" + 
        "\n" + 
        "The integer is represented using length bytes.  An OverflowError is\n" + 
        "raised if the integer is not representable with the given number of\n" + 
        "bytes.\n" + 
        "\n" + 
        "The byteorder argument determines the byte order used to represent the\n" + 
        "integer.  If byteorder is 'big', the most significant byte is at the\n" + 
        "beginning of the byte array.  If byteorder is 'little', the most\n" + 
        "significant byte is at the end of the byte array.  To request the native\n" + 
        "byte order of the host system, use `sys.byteorder' as the byte order value.\n" + 
        "\n" + 
        "The signed keyword-only argument determines whether two's complement is\n" + 
        "used to represent the integer.  If signed is False and a negative integer\n" + 
        "is given, an OverflowError is raised.";

    // Docs for <class 'classmethod'>
    public final static String classmethod___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String classmethod___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String classmethod___dict___doc = 
        "";

    public final static String classmethod___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String classmethod_doc = 
        "classmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a class method.\n" + 
        "\n" + 
        "A class method receives the class as implicit first argument,\n" + 
        "just like an instance method receives the instance.\n" + 
        "To declare a class method, use this idiom:\n" + 
        "\n" + 
        "  class C:\n" + 
        "      def f(cls, arg1, arg2, ...): ...\n" + 
        "      f = classmethod(f)\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "If a class method is called for a derived class, the derived class\n" + 
        "object is passed as the implied first argument.\n" + 
        "\n" + 
        "Class methods are different than C++ or Java static methods.\n" + 
        "If you want those, see the staticmethod builtin.";

    public final static String classmethod___eq___doc = 
        "Return self==value.";

    public final static String classmethod___format___doc = 
        "default object formatter";

    public final static String classmethod___func___doc = 
        "";

    public final static String classmethod___ge___doc = 
        "Return self>=value.";

    public final static String classmethod___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String classmethod___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String classmethod___gt___doc = 
        "Return self>value.";

    public final static String classmethod___hash___doc = 
        "Return hash(self).";

    public final static String classmethod___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String classmethod___isabstractmethod___doc = 
        "";

    public final static String classmethod___le___doc = 
        "Return self<=value.";

    public final static String classmethod___lt___doc = 
        "Return self<value.";

    public final static String classmethod___ne___doc = 
        "Return self!=value.";

    public final static String classmethod___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String classmethod___reduce___doc = 
        "helper for pickle";

    public final static String classmethod___reduce_ex___doc = 
        "helper for pickle";

    public final static String classmethod___repr___doc = 
        "Return repr(self).";

    public final static String classmethod___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String classmethod___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String classmethod___str___doc = 
        "Return str(self).";

    public final static String classmethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'set'>
    public final static String set___and___doc = 
        "Return self&value.";

    public final static String set___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String set___contains___doc = 
        "x.__contains__(y) <==> y in x.";

    public final static String set___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String set___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String set_doc = 
        "set() -> new empty set object\n" + 
        "set(iterable) -> new set object\n" + 
        "\n" + 
        "Build an unordered collection of unique elements.";

    public final static String set___eq___doc = 
        "Return self==value.";

    public final static String set___format___doc = 
        "default object formatter";

    public final static String set___ge___doc = 
        "Return self>=value.";

    public final static String set___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String set___gt___doc = 
        "Return self>value.";

    public final static String set___hash___doc = 
        "";

    public final static String set___iand___doc = 
        "Return self&=value.";

    public final static String set___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String set___ior___doc = 
        "Return self|=value.";

    public final static String set___isub___doc = 
        "Return self-=value.";

    public final static String set___iter___doc = 
        "Implement iter(self).";

    public final static String set___ixor___doc = 
        "Return self^=value.";

    public final static String set___le___doc = 
        "Return self<=value.";

    public final static String set___len___doc = 
        "Return len(self).";

    public final static String set___lt___doc = 
        "Return self<value.";

    public final static String set___ne___doc = 
        "Return self!=value.";

    public final static String set___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String set___or___doc = 
        "Return self|value.";

    public final static String set___rand___doc = 
        "Return value&self.";

    public final static String set___reduce___doc = 
        "Return state information for pickling.";

    public final static String set___reduce_ex___doc = 
        "helper for pickle";

    public final static String set___repr___doc = 
        "Return repr(self).";

    public final static String set___ror___doc = 
        "Return value|self.";

    public final static String set___rsub___doc = 
        "Return value-self.";

    public final static String set___rxor___doc = 
        "Return value^self.";

    public final static String set___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String set___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String set___str___doc = 
        "Return str(self).";

    public final static String set___sub___doc = 
        "Return self-value.";

    public final static String set___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String set___xor___doc = 
        "Return self^value.";

    public final static String set_add_doc = 
        "Add an element to a set.\n" + 
        "\n" + 
        "This has no effect if the element is already present.";

    public final static String set_clear_doc = 
        "Remove all elements from this set.";

    public final static String set_copy_doc = 
        "Return a shallow copy of a set.";

    public final static String set_difference_doc = 
        "Return the difference of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in this set but not the others.)";

    public final static String set_difference_update_doc = 
        "Remove all elements of another set from this set.";

    public final static String set_discard_doc = 
        "Remove an element from a set if it is a member.\n" + 
        "\n" + 
        "If the element is not a member, do nothing.";

    public final static String set_intersection_doc = 
        "Return the intersection of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in both sets.)";

    public final static String set_intersection_update_doc = 
        "Update a set with the intersection of itself and another.";

    public final static String set_isdisjoint_doc = 
        "Return True if two sets have a null intersection.";

    public final static String set_issubset_doc = 
        "Report whether another set contains this set.";

    public final static String set_issuperset_doc = 
        "Report whether this set contains another set.";

    public final static String set_pop_doc = 
        "Remove and return an arbitrary set element.\n" + 
        "Raises KeyError if the set is empty.";

    public final static String set_remove_doc = 
        "Remove an element from a set; it must be a member.\n" + 
        "\n" + 
        "If the element is not a member, raise a KeyError.";

    public final static String set_symmetric_difference_doc = 
        "Return the symmetric difference of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in exactly one of the sets.)";

    public final static String set_symmetric_difference_update_doc = 
        "Update a set with the symmetric difference of itself and another.";

    public final static String set_union_doc = 
        "Return the union of sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in either set.)";

    public final static String set_update_doc = 
        "Update a set with the union of itself and others.";

    // Docs for <class 'frozenset'>
    public final static String frozenset___and___doc = 
        "Return self&value.";

    public final static String frozenset___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String frozenset___contains___doc = 
        "x.__contains__(y) <==> y in x.";

    public final static String frozenset___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String frozenset___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String frozenset_doc = 
        "frozenset() -> empty frozenset object\n" + 
        "frozenset(iterable) -> frozenset object\n" + 
        "\n" + 
        "Build an immutable unordered collection of unique elements.";

    public final static String frozenset___eq___doc = 
        "Return self==value.";

    public final static String frozenset___format___doc = 
        "default object formatter";

    public final static String frozenset___ge___doc = 
        "Return self>=value.";

    public final static String frozenset___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String frozenset___gt___doc = 
        "Return self>value.";

    public final static String frozenset___hash___doc = 
        "Return hash(self).";

    public final static String frozenset___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String frozenset___iter___doc = 
        "Implement iter(self).";

    public final static String frozenset___le___doc = 
        "Return self<=value.";

    public final static String frozenset___len___doc = 
        "Return len(self).";

    public final static String frozenset___lt___doc = 
        "Return self<value.";

    public final static String frozenset___ne___doc = 
        "Return self!=value.";

    public final static String frozenset___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String frozenset___or___doc = 
        "Return self|value.";

    public final static String frozenset___rand___doc = 
        "Return value&self.";

    public final static String frozenset___reduce___doc = 
        "Return state information for pickling.";

    public final static String frozenset___reduce_ex___doc = 
        "helper for pickle";

    public final static String frozenset___repr___doc = 
        "Return repr(self).";

    public final static String frozenset___ror___doc = 
        "Return value|self.";

    public final static String frozenset___rsub___doc = 
        "Return value-self.";

    public final static String frozenset___rxor___doc = 
        "Return value^self.";

    public final static String frozenset___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String frozenset___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String frozenset___str___doc = 
        "Return str(self).";

    public final static String frozenset___sub___doc = 
        "Return self-value.";

    public final static String frozenset___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String frozenset___xor___doc = 
        "Return self^value.";

    public final static String frozenset_copy_doc = 
        "Return a shallow copy of a set.";

    public final static String frozenset_difference_doc = 
        "Return the difference of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in this set but not the others.)";

    public final static String frozenset_intersection_doc = 
        "Return the intersection of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in both sets.)";

    public final static String frozenset_isdisjoint_doc = 
        "Return True if two sets have a null intersection.";

    public final static String frozenset_issubset_doc = 
        "Report whether another set contains this set.";

    public final static String frozenset_issuperset_doc = 
        "Report whether this set contains another set.";

    public final static String frozenset_symmetric_difference_doc = 
        "Return the symmetric difference of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in exactly one of the sets.)";

    public final static String frozenset_union_doc = 
        "Return the union of sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in either set.)";

    // Docs for <class 'BaseException'>
    public final static String BaseException___cause___doc = 
        "exception cause";

    public final static String BaseException___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String BaseException___context___doc = 
        "exception context";

    public final static String BaseException___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String BaseException___dict___doc = 
        "";

    public final static String BaseException___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String BaseException_doc = 
        "Common base class for all exceptions";

    public final static String BaseException___eq___doc = 
        "Return self==value.";

    public final static String BaseException___format___doc = 
        "default object formatter";

    public final static String BaseException___ge___doc = 
        "Return self>=value.";

    public final static String BaseException___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String BaseException___gt___doc = 
        "Return self>value.";

    public final static String BaseException___hash___doc = 
        "Return hash(self).";

    public final static String BaseException___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String BaseException___le___doc = 
        "Return self<=value.";

    public final static String BaseException___lt___doc = 
        "Return self<value.";

    public final static String BaseException___ne___doc = 
        "Return self!=value.";

    public final static String BaseException___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String BaseException___reduce___doc = 
        "";

    public final static String BaseException___reduce_ex___doc = 
        "helper for pickle";

    public final static String BaseException___repr___doc = 
        "Return repr(self).";

    public final static String BaseException___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String BaseException___setstate___doc = 
        "";

    public final static String BaseException___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String BaseException___str___doc = 
        "Return str(self).";

    public final static String BaseException___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String BaseException___suppress_context___doc = 
        "";

    public final static String BaseException___traceback___doc = 
        "";

    public final static String BaseException_args_doc = 
        "";

    public final static String BaseException_with_traceback_doc = 
        "Exception.with_traceback(tb) --\n" + 
        "    set self.__traceback__ to tb and return self.";

    // Docs for <class 'bytearray'>
    public final static String bytearray___add___doc = 
        "Return self+value.";

    public final static String bytearray___alloc___doc = 
        "B.__alloc__() -> int\n" + 
        "\n" + 
        "Return the number of bytes actually allocated.";

    public final static String bytearray___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bytearray___contains___doc = 
        "Return key in self.";

    public final static String bytearray___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String bytearray___delitem___doc = 
        "Delete self[key].";

    public final static String bytearray___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String bytearray_doc = 
        "bytearray(iterable_of_ints) -> bytearray\n" + 
        "bytearray(string, encoding[, errors]) -> bytearray\n" + 
        "bytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\n" + 
        "bytearray(int) -> bytes array of size given by the parameter initialized with null bytes\n" + 
        "bytearray() -> empty bytes array\n" + 
        "\n" + 
        "Construct an mutable bytearray object from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - a bytes or a buffer object\n" + 
        "  - any object implementing the buffer API.\n" + 
        "  - an integer";

    public final static String bytearray___eq___doc = 
        "Return self==value.";

    public final static String bytearray___format___doc = 
        "default object formatter";

    public final static String bytearray___ge___doc = 
        "Return self>=value.";

    public final static String bytearray___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String bytearray___getitem___doc = 
        "Return self[key].";

    public final static String bytearray___gt___doc = 
        "Return self>value.";

    public final static String bytearray___hash___doc = 
        "";

    public final static String bytearray___iadd___doc = 
        "Implement self+=value.";

    public final static String bytearray___imul___doc = 
        "Implement self*=value.";

    public final static String bytearray___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String bytearray___iter___doc = 
        "Implement iter(self).";

    public final static String bytearray___le___doc = 
        "Return self<=value.";

    public final static String bytearray___len___doc = 
        "Return len(self).";

    public final static String bytearray___lt___doc = 
        "Return self<value.";

    public final static String bytearray___mod___doc = 
        "Return self%value.";

    public final static String bytearray___mul___doc = 
        "Return self*value.n";

    public final static String bytearray___ne___doc = 
        "Return self!=value.";

    public final static String bytearray___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String bytearray___reduce___doc = 
        "Return state information for pickling.";

    public final static String bytearray___reduce_ex___doc = 
        "Return state information for pickling.";

    public final static String bytearray___repr___doc = 
        "Return repr(self).";

    public final static String bytearray___rmod___doc = 
        "Return value%self.";

    public final static String bytearray___rmul___doc = 
        "Return self*value.";

    public final static String bytearray___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String bytearray___setitem___doc = 
        "Set self[key] to value.";

    public final static String bytearray___sizeof___doc = 
        "Returns the size of the bytearray object in memory, in bytes.";

    public final static String bytearray___str___doc = 
        "Return str(self).";

    public final static String bytearray___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bytearray_append_doc = 
        "Append a single item to the end of the bytearray.\n" + 
        "\n" + 
        "  item\n" + 
        "    The item to be appended.";

    public final static String bytearray_capitalize_doc = 
        "B.capitalize() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with only its first character capitalized (ASCII)\n" + 
        "and the rest lower-cased.";

    public final static String bytearray_center_doc = 
        "B.center(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B centered in a string of length width.  Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytearray_clear_doc = 
        "Remove all items from the bytearray.";

    public final static String bytearray_copy_doc = 
        "Return a copy of B.";

    public final static String bytearray_count_doc = 
        "B.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of subsection sub in\n" + 
        "bytes B[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String bytearray_decode_doc = 
        "Decode the bytearray using the codec registered for encoding.\n" + 
        "\n" + 
        "  encoding\n" + 
        "    The encoding with which to decode the bytearray.\n" + 
        "  errors\n" + 
        "    The error handling scheme to use for the handling of decoding errors.\n" + 
        "    The default is 'strict' meaning that decoding errors raise a\n" + 
        "    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "    as well as any other name registered with codecs.register_error that\n" + 
        "    can handle UnicodeDecodeErrors.";

    public final static String bytearray_endswith_doc = 
        "B.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "suffix can also be a tuple of bytes to try.";

    public final static String bytearray_expandtabs_doc = 
        "B.expandtabs(tabsize=8) -> copy of B\n" + 
        "\n" + 
        "Return a copy of B where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String bytearray_extend_doc = 
        "Append all the items from the iterator or sequence to the end of the bytearray.\n" + 
        "\n" + 
        "  iterable_of_ints\n" + 
        "    The iterable of items to append.";

    public final static String bytearray_find_doc = 
        "B.find(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytearray_fromhex_doc = 
        "Create a bytearray object from a string of hexadecimal numbers.\n" + 
        "\n" + 
        "Spaces between two numbers are accepted.\n" + 
        "Example: bytearray.fromhex('B9 01EF') -> bytearray(b'\\\\xb9\\\\x01\\\\xef')";

    public final static String bytearray_hex_doc = 
        "B.hex() -> string\n" + 
        "\n" + 
        "Create a string of hexadecimal numbers from a bytearray object.\n" + 
        "Example: bytearray([0xb9, 0x01, 0xef]).hex() -> 'b901ef'.";

    public final static String bytearray_index_doc = 
        "B.index(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Like B.find() but raise ValueError when the subsection is not found.";

    public final static String bytearray_insert_doc = 
        "Insert a single item into the bytearray before the given index.\n" + 
        "\n" + 
        "  index\n" + 
        "    The index where the value is to be inserted.\n" + 
        "  item\n" + 
        "    The item to be inserted.";

    public final static String bytearray_isalnum_doc = 
        "B.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphanumeric\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_isalpha_doc = 
        "B.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphabetic\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_isdigit_doc = 
        "B.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are digits\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_islower_doc = 
        "B.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are lowercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytearray_isspace_doc = 
        "B.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are whitespace\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_istitle_doc = 
        "B.istitle() -> bool\n" + 
        "\n" + 
        "Return True if B is a titlecased string and there is at least one\n" + 
        "character in B, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String bytearray_isupper_doc = 
        "B.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are uppercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytearray_join_doc = 
        "Concatenate any number of bytes/bytearray objects.\n" + 
        "\n" + 
        "The bytearray whose method is called is inserted in between each pair.\n" + 
        "\n" + 
        "The result is returned as a new bytearray object.";

    public final static String bytearray_ljust_doc = 
        "B.ljust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B left justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytearray_lower_doc = 
        "B.lower() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to lowercase.";

    public final static String bytearray_lstrip_doc = 
        "Strip leading bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading ASCII whitespace.";

    public final static String bytearray_maketrans_doc = 
        "Return a translation table useable for the bytes or bytearray translate method.\n" + 
        "\n" + 
        "The returned table will be one where each byte in frm is mapped to the byte at\n" + 
        "the same position in to.\n" + 
        "\n" + 
        "The bytes objects frm and to must be of the same length.";

    public final static String bytearray_partition_doc = 
        "Partition the bytearray into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytearray. If the separator is\n" + 
        "found, returns a 3-tuple containing the part before the separator, the\n" + 
        "separator itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing the original\n" + 
        "bytearray object and two empty bytearray objects.";

    public final static String bytearray_pop_doc = 
        "Remove and return a single item from B.\n" + 
        "\n" + 
        "  index\n" + 
        "    The index from where to remove the item.\n" + 
        "    -1 (the default value) means remove the last item.\n" + 
        "\n" + 
        "If no index argument is given, will pop the last item.";

    public final static String bytearray_remove_doc = 
        "Remove the first occurrence of a value in the bytearray.\n" + 
        "\n" + 
        "  value\n" + 
        "    The value to remove.";

    public final static String bytearray_replace_doc = 
        "Return a copy with all occurrences of substring old replaced by new.\n" + 
        "\n" + 
        "  count\n" + 
        "    Maximum number of occurrences to replace.\n" + 
        "    -1 (the default value) means replace all occurrences.\n" + 
        "\n" + 
        "If the optional argument count is given, only the first count occurrences are\n" + 
        "replaced.";

    public final static String bytearray_reverse_doc = 
        "Reverse the order of the values in B in place.";

    public final static String bytearray_rfind_doc = 
        "B.rfind(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytearray_rindex_doc = 
        "B.rindex(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Like B.rfind() but raise ValueError when the subsection is not found.";

    public final static String bytearray_rjust_doc = 
        "B.rjust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B right justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String bytearray_rpartition_doc = 
        "Partition the bytes into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytearray, starting and the end.\n" + 
        "If the separator is found, returns a 3-tuple containing the part before the\n" + 
        "separator, the separator itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing two empty bytearray\n" + 
        "objects and the original bytearray object.";

    public final static String bytearray_rsplit_doc = 
        "Return a list of the sections in the bytearray, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytearray.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.\n" + 
        "\n" + 
        "Splitting is done starting at the end of the bytearray and working to the front.";

    public final static String bytearray_rstrip_doc = 
        "Strip trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip trailing ASCII whitespace.";

    public final static String bytearray_split_doc = 
        "Return a list of the sections in the bytearray, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytearray.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.";

    public final static String bytearray_splitlines_doc = 
        "Return a list of the lines in the bytearray, breaking at line boundaries.\n" + 
        "\n" + 
        "Line breaks are not included in the resulting list unless keepends is given and\n" + 
        "true.";

    public final static String bytearray_startswith_doc = 
        "B.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "prefix can also be a tuple of bytes to try.";

    public final static String bytearray_strip_doc = 
        "Strip leading and trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading and trailing ASCII whitespace.";

    public final static String bytearray_swapcase_doc = 
        "B.swapcase() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with uppercase ASCII characters converted\n" + 
        "to lowercase ASCII and vice versa.";

    public final static String bytearray_title_doc = 
        "B.title() -> copy of B\n" + 
        "\n" + 
        "Return a titlecased version of B, i.e. ASCII words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String bytearray_translate_doc = 
        "translate(table, [deletechars])\n" + 
        "Return a copy with each character mapped by the given translation table.\n" + 
        "\n" + 
        "  table\n" + 
        "    Translation table, which must be a bytes object of length 256.\n" + 
        "\n" + 
        "All characters occurring in the optional argument deletechars are removed.\n" + 
        "The remaining characters are mapped through the given translation table.";

    public final static String bytearray_upper_doc = 
        "B.upper() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to uppercase.";

    public final static String bytearray_zfill_doc = 
        "B.zfill(width) -> copy of B\n" + 
        "\n" + 
        "Pad a numeric string B with zeros on the left, to fill a field\n" + 
        "of the specified width.  B is never truncated.";

    // Docs for <class 'memoryview'>
    public final static String memoryview___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String memoryview___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String memoryview___delitem___doc = 
        "Delete self[key].";

    public final static String memoryview___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String memoryview_doc = 
        "Create a new memoryview object which references the given object.";

    public final static String memoryview___enter___doc = 
        "";

    public final static String memoryview___eq___doc = 
        "Return self==value.";

    public final static String memoryview___exit___doc = 
        "";

    public final static String memoryview___format___doc = 
        "default object formatter";

    public final static String memoryview___ge___doc = 
        "Return self>=value.";

    public final static String memoryview___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String memoryview___getitem___doc = 
        "Return self[key].";

    public final static String memoryview___gt___doc = 
        "Return self>value.";

    public final static String memoryview___hash___doc = 
        "Return hash(self).";

    public final static String memoryview___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String memoryview___le___doc = 
        "Return self<=value.";

    public final static String memoryview___len___doc = 
        "Return len(self).";

    public final static String memoryview___lt___doc = 
        "Return self<value.";

    public final static String memoryview___ne___doc = 
        "Return self!=value.";

    public final static String memoryview___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String memoryview___reduce___doc = 
        "helper for pickle";

    public final static String memoryview___reduce_ex___doc = 
        "helper for pickle";

    public final static String memoryview___repr___doc = 
        "Return repr(self).";

    public final static String memoryview___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String memoryview___setitem___doc = 
        "Set self[key] to value.";

    public final static String memoryview___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String memoryview___str___doc = 
        "Return str(self).";

    public final static String memoryview___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String memoryview_c_contiguous_doc = 
        "A bool indicating whether the memory is C contiguous.";

    public final static String memoryview_cast_doc = 
        "Cast a memoryview to a new format or shape.";

    public final static String memoryview_contiguous_doc = 
        "A bool indicating whether the memory is contiguous.";

    public final static String memoryview_f_contiguous_doc = 
        "A bool indicating whether the memory is Fortran contiguous.";

    public final static String memoryview_format_doc = 
        "A string containing the format (in struct module style)\n" + 
        " for each element in the view.";

    public final static String memoryview_hex_doc = 
        "Return the data in the buffer as a string of hexadecimal numbers.";

    public final static String memoryview_itemsize_doc = 
        "The size in bytes of each element of the memoryview.";

    public final static String memoryview_nbytes_doc = 
        "The amount of space in bytes that the array would use in\n" + 
        " a contiguous representation.";

    public final static String memoryview_ndim_doc = 
        "An integer indicating how many dimensions of a multi-dimensional\n" + 
        " array the memory represents.";

    public final static String memoryview_obj_doc = 
        "The underlying object of the memoryview.";

    public final static String memoryview_readonly_doc = 
        "A bool indicating whether the memory is read only.";

    public final static String memoryview_release_doc = 
        "Release the underlying buffer exposed by the memoryview object.";

    public final static String memoryview_shape_doc = 
        "A tuple of ndim integers giving the shape of the memory\n" + 
        " as an N-dimensional array.";

    public final static String memoryview_strides_doc = 
        "A tuple of ndim integers giving the size in bytes to access\n" + 
        " each element for each dimension of the array.";

    public final static String memoryview_suboffsets_doc = 
        "A tuple of integers used internally for PIL-style arrays.";

    public final static String memoryview_tobytes_doc = 
        "Return the data in the buffer as a byte string.";

    public final static String memoryview_tolist_doc = 
        "Return the data in the buffer as a list of elements.";

    // Docs for <class 'generator'>
    public final static String generator___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String generator___del___doc = 
        "";

    public final static String generator___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String generator___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String generator_doc = 
        "";

    public final static String generator___eq___doc = 
        "Return self==value.";

    public final static String generator___format___doc = 
        "default object formatter";

    public final static String generator___ge___doc = 
        "Return self>=value.";

    public final static String generator___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String generator___gt___doc = 
        "Return self>value.";

    public final static String generator___hash___doc = 
        "Return hash(self).";

    public final static String generator___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String generator___iter___doc = 
        "Implement iter(self).";

    public final static String generator___le___doc = 
        "Return self<=value.";

    public final static String generator___lt___doc = 
        "Return self<value.";

    public final static String generator___name___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String generator___ne___doc = 
        "Return self!=value.";

    public final static String generator___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String generator___next___doc = 
        "Implement next(self).";

    public final static String generator___qualname___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String generator___reduce___doc = 
        "helper for pickle";

    public final static String generator___reduce_ex___doc = 
        "helper for pickle";

    public final static String generator___repr___doc = 
        "Return repr(self).";

    public final static String generator___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String generator___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String generator___str___doc = 
        "Return str(self).";

    public final static String generator___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String generator_close_doc = 
        "close() -> raise GeneratorExit inside generator.";

    public final static String generator_gi_code_doc = 
        "";

    public final static String generator_gi_frame_doc = 
        "";

    public final static String generator_gi_running_doc = 
        "";

    public final static String generator_gi_yieldfrom_doc = 
        "object being iterated by yield from, or None";

    public final static String generator_send_doc = 
        "send(arg) -> send 'arg' into generator,\n" + 
        "return next yielded value or raise StopIteration.";

    public final static String generator_throw_doc = 
        "throw(typ[,val[,tb]]) -> raise exception in generator,\n" + 
        "return next yielded value or raise StopIteration.";

    // Docs for <class 'coroutine'>
    public final static String coroutine___await___doc = 
        "Return an iterator to be used in await expression.";

    public final static String coroutine___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String coroutine___del___doc = 
        "";

    public final static String coroutine___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String coroutine___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String coroutine_doc = 
        "";

    public final static String coroutine___eq___doc = 
        "Return self==value.";

    public final static String coroutine___format___doc = 
        "default object formatter";

    public final static String coroutine___ge___doc = 
        "Return self>=value.";

    public final static String coroutine___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String coroutine___gt___doc = 
        "Return self>value.";

    public final static String coroutine___hash___doc = 
        "Return hash(self).";

    public final static String coroutine___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String coroutine___le___doc = 
        "Return self<=value.";

    public final static String coroutine___lt___doc = 
        "Return self<value.";

    public final static String coroutine___name___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String coroutine___ne___doc = 
        "Return self!=value.";

    public final static String coroutine___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String coroutine___qualname___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String coroutine___reduce___doc = 
        "helper for pickle";

    public final static String coroutine___reduce_ex___doc = 
        "helper for pickle";

    public final static String coroutine___repr___doc = 
        "Return repr(self).";

    public final static String coroutine___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String coroutine___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String coroutine___str___doc = 
        "Return str(self).";

    public final static String coroutine___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String coroutine_close_doc = 
        "close() -> raise GeneratorExit inside coroutine.";

    public final static String coroutine_cr_await_doc = 
        "object being awaited on, or None";

    public final static String coroutine_cr_code_doc = 
        "";

    public final static String coroutine_cr_frame_doc = 
        "";

    public final static String coroutine_cr_running_doc = 
        "";

    public final static String coroutine_send_doc = 
        "send(arg) -> send 'arg' into coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    public final static String coroutine_throw_doc = 
        "throw(typ[,val[,tb]]) -> raise exception in coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    // Docs for <class 'coroutine_wrapper'>
    public final static String coroutine_wrapper___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String coroutine_wrapper___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String coroutine_wrapper___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String coroutine_wrapper_doc = 
        "A wrapper object implementing __await__ for coroutines.";

    public final static String coroutine_wrapper___eq___doc = 
        "Return self==value.";

    public final static String coroutine_wrapper___format___doc = 
        "default object formatter";

    public final static String coroutine_wrapper___ge___doc = 
        "Return self>=value.";

    public final static String coroutine_wrapper___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String coroutine_wrapper___gt___doc = 
        "Return self>value.";

    public final static String coroutine_wrapper___hash___doc = 
        "Return hash(self).";

    public final static String coroutine_wrapper___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String coroutine_wrapper___iter___doc = 
        "Implement iter(self).";

    public final static String coroutine_wrapper___le___doc = 
        "Return self<=value.";

    public final static String coroutine_wrapper___lt___doc = 
        "Return self<value.";

    public final static String coroutine_wrapper___ne___doc = 
        "Return self!=value.";

    public final static String coroutine_wrapper___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String coroutine_wrapper___next___doc = 
        "Implement next(self).";

    public final static String coroutine_wrapper___reduce___doc = 
        "helper for pickle";

    public final static String coroutine_wrapper___reduce_ex___doc = 
        "helper for pickle";

    public final static String coroutine_wrapper___repr___doc = 
        "Return repr(self).";

    public final static String coroutine_wrapper___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String coroutine_wrapper___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String coroutine_wrapper___str___doc = 
        "Return str(self).";

    public final static String coroutine_wrapper___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String coroutine_wrapper_close_doc = 
        "close() -> raise GeneratorExit inside coroutine.";

    public final static String coroutine_wrapper_send_doc = 
        "send(arg) -> send 'arg' into coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    public final static String coroutine_wrapper_throw_doc = 
        "throw(typ[,val[,tb]]) -> raise exception in coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    // Docs for <class 'function'>
    public final static String function___annotations___doc = 
        "";

    public final static String function___call___doc = 
        "Call self as a function.";

    public final static String function___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String function___closure___doc = 
        "";

    public final static String function___code___doc = 
        "";

    public final static String function___defaults___doc = 
        "";

    public final static String function___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String function___dict___doc = 
        "";

    public final static String function___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String function_doc = 
        "function(code, globals[, name[, argdefs[, closure]]])\n" + 
        "\n" + 
        "Create a function object from a code object and a dictionary.\n" + 
        "The optional name string overrides the name from the code object.\n" + 
        "The optional argdefs tuple specifies the default argument values.\n" + 
        "The optional closure tuple supplies the bindings for free variables.";

    public final static String function___eq___doc = 
        "Return self==value.";

    public final static String function___format___doc = 
        "default object formatter";

    public final static String function___ge___doc = 
        "Return self>=value.";

    public final static String function___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String function___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String function___globals___doc = 
        "";

    public final static String function___gt___doc = 
        "Return self>value.";

    public final static String function___hash___doc = 
        "Return hash(self).";

    public final static String function___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String function___kwdefaults___doc = 
        "";

    public final static String function___le___doc = 
        "Return self<=value.";

    public final static String function___lt___doc = 
        "Return self<value.";

    public final static String function___module___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String function___name___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String function___ne___doc = 
        "Return self!=value.";

    public final static String function___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String function___qualname___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String function___reduce___doc = 
        "helper for pickle";

    public final static String function___reduce_ex___doc = 
        "helper for pickle";

    public final static String function___repr___doc = 
        "Return repr(self).";

    public final static String function___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String function___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String function___str___doc = 
        "Return str(self).";

    public final static String function___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'code'>
    public final static String code___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String code___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String code___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String code_doc = 
        "code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,\n" + 
        "      constants, names, varnames, filename, name, firstlineno,\n" + 
        "      lnotab[, freevars[, cellvars]])\n" + 
        "\n" + 
        "Create a code object.  Not for the faint of heart.";

    public final static String code___eq___doc = 
        "Return self==value.";

    public final static String code___format___doc = 
        "default object formatter";

    public final static String code___ge___doc = 
        "Return self>=value.";

    public final static String code___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String code___gt___doc = 
        "Return self>value.";

    public final static String code___hash___doc = 
        "Return hash(self).";

    public final static String code___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String code___le___doc = 
        "Return self<=value.";

    public final static String code___lt___doc = 
        "Return self<value.";

    public final static String code___ne___doc = 
        "Return self!=value.";

    public final static String code___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String code___reduce___doc = 
        "helper for pickle";

    public final static String code___reduce_ex___doc = 
        "helper for pickle";

    public final static String code___repr___doc = 
        "Return repr(self).";

    public final static String code___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String code___sizeof___doc = 
        "";

    public final static String code___str___doc = 
        "Return str(self).";

    public final static String code___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String code_co_argcount_doc = 
        "";

    public final static String code_co_cellvars_doc = 
        "";

    public final static String code_co_code_doc = 
        "";

    public final static String code_co_consts_doc = 
        "";

    public final static String code_co_filename_doc = 
        "";

    public final static String code_co_firstlineno_doc = 
        "";

    public final static String code_co_flags_doc = 
        "";

    public final static String code_co_freevars_doc = 
        "";

    public final static String code_co_kwonlyargcount_doc = 
        "";

    public final static String code_co_lnotab_doc = 
        "";

    public final static String code_co_name_doc = 
        "";

    public final static String code_co_names_doc = 
        "";

    public final static String code_co_nlocals_doc = 
        "";

    public final static String code_co_stacksize_doc = 
        "";

    public final static String code_co_varnames_doc = 
        "";

    // Docs for <class 'types.SimpleNamespace'>
    public final static String SimpleNamespace___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String SimpleNamespace___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String SimpleNamespace___dict___doc = 
        "";

    public final static String SimpleNamespace___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String SimpleNamespace_doc = 
        "A simple attribute-based namespace.\n" + 
        "\n" + 
        "SimpleNamespace(**kwargs)";

    public final static String SimpleNamespace___eq___doc = 
        "Return self==value.";

    public final static String SimpleNamespace___format___doc = 
        "default object formatter";

    public final static String SimpleNamespace___ge___doc = 
        "Return self>=value.";

    public final static String SimpleNamespace___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String SimpleNamespace___gt___doc = 
        "Return self>value.";

    public final static String SimpleNamespace___hash___doc = 
        "";

    public final static String SimpleNamespace___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String SimpleNamespace___le___doc = 
        "Return self<=value.";

    public final static String SimpleNamespace___lt___doc = 
        "Return self<value.";

    public final static String SimpleNamespace___ne___doc = 
        "Return self!=value.";

    public final static String SimpleNamespace___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String SimpleNamespace___reduce___doc = 
        "Return state information for pickling";

    public final static String SimpleNamespace___reduce_ex___doc = 
        "helper for pickle";

    public final static String SimpleNamespace___repr___doc = 
        "Return repr(self).";

    public final static String SimpleNamespace___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String SimpleNamespace___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String SimpleNamespace___str___doc = 
        "Return str(self).";

    public final static String SimpleNamespace___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'frame'>
    public final static String frame___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String frame___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String frame___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String frame_doc = 
        "";

    public final static String frame___eq___doc = 
        "Return self==value.";

    public final static String frame___format___doc = 
        "default object formatter";

    public final static String frame___ge___doc = 
        "Return self>=value.";

    public final static String frame___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String frame___gt___doc = 
        "Return self>value.";

    public final static String frame___hash___doc = 
        "Return hash(self).";

    public final static String frame___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String frame___le___doc = 
        "Return self<=value.";

    public final static String frame___lt___doc = 
        "Return self<value.";

    public final static String frame___ne___doc = 
        "Return self!=value.";

    public final static String frame___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String frame___reduce___doc = 
        "helper for pickle";

    public final static String frame___reduce_ex___doc = 
        "helper for pickle";

    public final static String frame___repr___doc = 
        "Return repr(self).";

    public final static String frame___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String frame___sizeof___doc = 
        "F.__sizeof__() -> size of F in memory, in bytes";

    public final static String frame___str___doc = 
        "Return str(self).";

    public final static String frame___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String frame_clear_doc = 
        "F.clear(): clear most references held by the frame";

    public final static String frame_f_back_doc = 
        "";

    public final static String frame_f_builtins_doc = 
        "";

    public final static String frame_f_code_doc = 
        "";

    public final static String frame_f_globals_doc = 
        "";

    public final static String frame_f_lasti_doc = 
        "";

    public final static String frame_f_lineno_doc = 
        "";

    public final static String frame_f_locals_doc = 
        "";

    public final static String frame_f_trace_doc = 
        "";

    // Docs for <class 'traceback'>
    public final static String traceback___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String traceback___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String traceback___dir___doc = 
        "";

    public final static String traceback_doc = 
        "";

    public final static String traceback___eq___doc = 
        "Return self==value.";

    public final static String traceback___format___doc = 
        "default object formatter";

    public final static String traceback___ge___doc = 
        "Return self>=value.";

    public final static String traceback___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String traceback___gt___doc = 
        "Return self>value.";

    public final static String traceback___hash___doc = 
        "Return hash(self).";

    public final static String traceback___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String traceback___le___doc = 
        "Return self<=value.";

    public final static String traceback___lt___doc = 
        "Return self<value.";

    public final static String traceback___ne___doc = 
        "Return self!=value.";

    public final static String traceback___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String traceback___reduce___doc = 
        "helper for pickle";

    public final static String traceback___reduce_ex___doc = 
        "helper for pickle";

    public final static String traceback___repr___doc = 
        "Return repr(self).";

    public final static String traceback___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String traceback___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String traceback___str___doc = 
        "Return str(self).";

    public final static String traceback___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String traceback_tb_frame_doc = 
        "";

    public final static String traceback_tb_lasti_doc = 
        "";

    public final static String traceback_tb_lineno_doc = 
        "";

    public final static String traceback_tb_next_doc = 
        "";

    // Docs for <class '_sre.SRE_Pattern'>
    public final static String SRE_Pattern___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String SRE_Pattern___copy___doc = 
        "";

    public final static String SRE_Pattern___deepcopy___doc = 
        "";

    public final static String SRE_Pattern___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String SRE_Pattern___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String SRE_Pattern_doc = 
        "Compiled regular expression objects";

    public final static String SRE_Pattern___eq___doc = 
        "Return self==value.";

    public final static String SRE_Pattern___format___doc = 
        "default object formatter";

    public final static String SRE_Pattern___ge___doc = 
        "Return self>=value.";

    public final static String SRE_Pattern___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String SRE_Pattern___gt___doc = 
        "Return self>value.";

    public final static String SRE_Pattern___hash___doc = 
        "Return hash(self).";

    public final static String SRE_Pattern___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String SRE_Pattern___le___doc = 
        "Return self<=value.";

    public final static String SRE_Pattern___lt___doc = 
        "Return self<value.";

    public final static String SRE_Pattern___ne___doc = 
        "Return self!=value.";

    public final static String SRE_Pattern___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String SRE_Pattern___reduce___doc = 
        "helper for pickle";

    public final static String SRE_Pattern___reduce_ex___doc = 
        "helper for pickle";

    public final static String SRE_Pattern___repr___doc = 
        "Return repr(self).";

    public final static String SRE_Pattern___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String SRE_Pattern___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String SRE_Pattern___str___doc = 
        "Return str(self).";

    public final static String SRE_Pattern___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String SRE_Pattern_findall_doc = 
        "Return a list of all non-overlapping matches of pattern in string.";

    public final static String SRE_Pattern_finditer_doc = 
        "Return an iterator over all non-overlapping matches for the RE pattern in string.\n" + 
        "\n" + 
        "For each match, the iterator returns a match object.";

    public final static String SRE_Pattern_flags_doc = 
        "";

    public final static String SRE_Pattern_fullmatch_doc = 
        "Matches against all of the string";

    public final static String SRE_Pattern_groupindex_doc = 
        "A dictionary mapping group names to group numbers.";

    public final static String SRE_Pattern_groups_doc = 
        "";

    public final static String SRE_Pattern_match_doc = 
        "Matches zero or more characters at the beginning of the string.";

    public final static String SRE_Pattern_pattern_doc = 
        "";

    public final static String SRE_Pattern_scanner_doc = 
        "";

    public final static String SRE_Pattern_search_doc = 
        "Scan through string looking for a match, and return a corresponding match object instance.\n" + 
        "\n" + 
        "Return None if no position in the string matches.";

    public final static String SRE_Pattern_split_doc = 
        "Split string by the occurrences of pattern.";

    public final static String SRE_Pattern_sub_doc = 
        "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.";

    public final static String SRE_Pattern_subn_doc = 
        "Return the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.";

    // Docs for <class '_sre.SRE_Match'>
    public final static String SRE_Match___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String SRE_Match___copy___doc = 
        "";

    public final static String SRE_Match___deepcopy___doc = 
        "";

    public final static String SRE_Match___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String SRE_Match___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String SRE_Match_doc = 
        "The result of re.match() and re.search().\n" + 
        "Match objects always have a boolean value of True.";

    public final static String SRE_Match___eq___doc = 
        "Return self==value.";

    public final static String SRE_Match___format___doc = 
        "default object formatter";

    public final static String SRE_Match___ge___doc = 
        "Return self>=value.";

    public final static String SRE_Match___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String SRE_Match___gt___doc = 
        "Return self>value.";

    public final static String SRE_Match___hash___doc = 
        "Return hash(self).";

    public final static String SRE_Match___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String SRE_Match___le___doc = 
        "Return self<=value.";

    public final static String SRE_Match___lt___doc = 
        "Return self<value.";

    public final static String SRE_Match___ne___doc = 
        "Return self!=value.";

    public final static String SRE_Match___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String SRE_Match___reduce___doc = 
        "helper for pickle";

    public final static String SRE_Match___reduce_ex___doc = 
        "helper for pickle";

    public final static String SRE_Match___repr___doc = 
        "Return repr(self).";

    public final static String SRE_Match___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String SRE_Match___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String SRE_Match___str___doc = 
        "Return str(self).";

    public final static String SRE_Match___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String SRE_Match_end_doc = 
        "Return index of the end of the substring matched by group.";

    public final static String SRE_Match_endpos_doc = 
        "";

    public final static String SRE_Match_expand_doc = 
        "Return the string obtained by doing backslash substitution on the string template, as done by the sub() method.";

    public final static String SRE_Match_group_doc = 
        "group([group1, ...]) -> str or tuple.\n" + 
        "    Return subgroup(s) of the match by indices or names.\n" + 
        "    For 0 returns the entire match.";

    public final static String SRE_Match_groupdict_doc = 
        "Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\n" + 
        "\n" + 
        "  default\n" + 
        "    Is used for groups that did not participate in the match.";

    public final static String SRE_Match_groups_doc = 
        "Return a tuple containing all the subgroups of the match, from 1.\n" + 
        "\n" + 
        "  default\n" + 
        "    Is used for groups that did not participate in the match.";

    public final static String SRE_Match_lastgroup_doc = 
        "";

    public final static String SRE_Match_lastindex_doc = 
        "";

    public final static String SRE_Match_pos_doc = 
        "";

    public final static String SRE_Match_re_doc = 
        "";

    public final static String SRE_Match_regs_doc = 
        "";

    public final static String SRE_Match_span_doc = 
        "For MatchObject m, return the 2-tuple (m.start(group), m.end(group)).";

    public final static String SRE_Match_start_doc = 
        "Return index of the start of the substring matched by group.";

    public final static String SRE_Match_string_doc = 
        "";

    // Docs for <class 'range_iterator'>
    public final static String range_iterator___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String range_iterator___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String range_iterator___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String range_iterator_doc = 
        "";

    public final static String range_iterator___eq___doc = 
        "Return self==value.";

    public final static String range_iterator___format___doc = 
        "default object formatter";

    public final static String range_iterator___ge___doc = 
        "Return self>=value.";

    public final static String range_iterator___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String range_iterator___gt___doc = 
        "Return self>value.";

    public final static String range_iterator___hash___doc = 
        "Return hash(self).";

    public final static String range_iterator___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String range_iterator___iter___doc = 
        "Implement iter(self).";

    public final static String range_iterator___le___doc = 
        "Return self<=value.";

    public final static String range_iterator___length_hint___doc = 
        "Private method returning an estimate of len(list(it)).";

    public final static String range_iterator___lt___doc = 
        "Return self<value.";

    public final static String range_iterator___ne___doc = 
        "Return self!=value.";

    public final static String range_iterator___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String range_iterator___next___doc = 
        "Implement next(self).";

    public final static String range_iterator___reduce___doc = 
        "Return state information for pickling.";

    public final static String range_iterator___reduce_ex___doc = 
        "helper for pickle";

    public final static String range_iterator___repr___doc = 
        "Return repr(self).";

    public final static String range_iterator___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String range_iterator___setstate___doc = 
        "Set state information for unpickling.";

    public final static String range_iterator___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String range_iterator___str___doc = 
        "Return str(self).";

    public final static String range_iterator___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'list_iterator'>
    public final static String list_iterator___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String list_iterator___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String list_iterator___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String list_iterator_doc = 
        "";

    public final static String list_iterator___eq___doc = 
        "Return self==value.";

    public final static String list_iterator___format___doc = 
        "default object formatter";

    public final static String list_iterator___ge___doc = 
        "Return self>=value.";

    public final static String list_iterator___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String list_iterator___gt___doc = 
        "Return self>value.";

    public final static String list_iterator___hash___doc = 
        "Return hash(self).";

    public final static String list_iterator___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String list_iterator___iter___doc = 
        "Implement iter(self).";

    public final static String list_iterator___le___doc = 
        "Return self<=value.";

    public final static String list_iterator___length_hint___doc = 
        "Private method returning an estimate of len(list(it)).";

    public final static String list_iterator___lt___doc = 
        "Return self<value.";

    public final static String list_iterator___ne___doc = 
        "Return self!=value.";

    public final static String list_iterator___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String list_iterator___next___doc = 
        "Implement next(self).";

    public final static String list_iterator___reduce___doc = 
        "Return state information for pickling.";

    public final static String list_iterator___reduce_ex___doc = 
        "helper for pickle";

    public final static String list_iterator___repr___doc = 
        "Return repr(self).";

    public final static String list_iterator___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String list_iterator___setstate___doc = 
        "Set state information for unpickling.";

    public final static String list_iterator___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String list_iterator___str___doc = 
        "Return str(self).";

    public final static String list_iterator___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'itertools.chain'>
    public final static String chain___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String chain___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String chain___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String chain_doc = 
        "chain(*iterables) --> chain object\n" + 
        "\n" + 
        "Return a chain object whose .__next__() method returns elements from the\n" + 
        "first iterable until it is exhausted, then elements from the next\n" + 
        "iterable, until all of the iterables are exhausted.";

    public final static String chain___eq___doc = 
        "Return self==value.";

    public final static String chain___format___doc = 
        "default object formatter";

    public final static String chain___ge___doc = 
        "Return self>=value.";

    public final static String chain___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String chain___gt___doc = 
        "Return self>value.";

    public final static String chain___hash___doc = 
        "Return hash(self).";

    public final static String chain___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String chain___iter___doc = 
        "Implement iter(self).";

    public final static String chain___le___doc = 
        "Return self<=value.";

    public final static String chain___lt___doc = 
        "Return self<value.";

    public final static String chain___ne___doc = 
        "Return self!=value.";

    public final static String chain___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String chain___next___doc = 
        "Implement next(self).";

    public final static String chain___reduce___doc = 
        "Return state information for pickling.";

    public final static String chain___reduce_ex___doc = 
        "helper for pickle";

    public final static String chain___repr___doc = 
        "Return repr(self).";

    public final static String chain___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String chain___setstate___doc = 
        "Set state information for unpickling.";

    public final static String chain___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String chain___str___doc = 
        "Return str(self).";

    public final static String chain___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String chain_from_iterable_doc = 
        "chain.from_iterable(iterable) --> chain object\n" + 
        "\n" + 
        "Alternate chain() contructor taking a single iterable argument\n" + 
        "that evaluates lazily.";

    // Docs for <class 'io.TextIOBase'>
    public final static String TextIOBase___abstractmethods___doc = 
        "";

    public final static String TextIOBase___class___doc = 
        "Metaclass for defining Abstract Base Classes (ABCs).\n" + 
        "\n" + 
        "    Use this metaclass to create an ABC.  An ABC can be subclassed\n" + 
        "    directly, and then acts as a mix-in class.  You can also register\n" + 
        "    unrelated concrete classes (even built-in classes) and unrelated\n" + 
        "    ABCs as 'virtual subclasses' -- these and their descendants will\n" + 
        "    be considered subclasses of the registering ABC by the built-in\n" + 
        "    issubclass() function, but the registering ABC won't show up in\n" + 
        "    their MRO (Method Resolution Order) nor will method\n" + 
        "    implementations defined by the registering ABC be callable (not\n" + 
        "    even via super()).\n" + 
        "\n" + 
        "    ";

    public final static String TextIOBase___del___doc = 
        "";

    public final static String TextIOBase___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String TextIOBase___dict___doc = 
        "";

    public final static String TextIOBase___dir___doc = 
        "__dir__() -> list\n" + 
        "default dir() implementation";

    public final static String TextIOBase_doc = 
        "Base class for text I/O.\n" + 
        "\n" + 
        "This class provides a character and line based interface to stream\n" + 
        "I/O. There is no readinto method because Python's character strings\n" + 
        "are immutable. There is no public constructor.\n" + 
        "";

    public final static String TextIOBase___enter___doc = 
        "";

    public final static String TextIOBase___eq___doc = 
        "Return self==value.";

    public final static String TextIOBase___exit___doc = 
        "";

    public final static String TextIOBase___format___doc = 
        "default object formatter";

    public final static String TextIOBase___ge___doc = 
        "Return self>=value.";

    public final static String TextIOBase___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String TextIOBase___gt___doc = 
        "Return self>value.";

    public final static String TextIOBase___hash___doc = 
        "Return hash(self).";

    public final static String TextIOBase___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String TextIOBase___iter___doc = 
        "Implement iter(self).";

    public final static String TextIOBase___le___doc = 
        "Return self<=value.";

    public final static String TextIOBase___lt___doc = 
        "Return self<value.";

    public final static String TextIOBase___module___doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String TextIOBase___ne___doc = 
        "Return self!=value.";

    public final static String TextIOBase___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String TextIOBase___next___doc = 
        "Implement next(self).";

    public final static String TextIOBase___reduce___doc = 
        "helper for pickle";

    public final static String TextIOBase___reduce_ex___doc = 
        "helper for pickle";

    public final static String TextIOBase___repr___doc = 
        "Return repr(self).";

    public final static String TextIOBase___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String TextIOBase___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String TextIOBase___str___doc = 
        "Return str(self).";

    public final static String TextIOBase___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String TextIOBase__abc_cache_doc = 
        "";

    public final static String TextIOBase__abc_negative_cache_doc = 
        "";

    public final static String TextIOBase__abc_negative_cache_version_doc = 
        "int(x=0) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String TextIOBase__abc_registry_doc = 
        "";

    public final static String TextIOBase__checkClosed_doc = 
        "";

    public final static String TextIOBase__checkReadable_doc = 
        "";

    public final static String TextIOBase__checkSeekable_doc = 
        "";

    public final static String TextIOBase__checkWritable_doc = 
        "";

    public final static String TextIOBase_close_doc = 
        "Flush and close the IO object.\n" + 
        "\n" + 
        "This method has no effect if the file is already closed.";

    public final static String TextIOBase_closed_doc = 
        "";

    public final static String TextIOBase_detach_doc = 
        "Separate the underlying buffer from the TextIOBase and return it.\n" + 
        "\n" + 
        "After the underlying buffer has been detached, the TextIO is in an\n" + 
        "unusable state.\n" + 
        "";

    public final static String TextIOBase_encoding_doc = 
        "Encoding of the text stream.\n" + 
        "\n" + 
        "Subclasses should override.\n" + 
        "";

    public final static String TextIOBase_errors_doc = 
        "The error setting of the decoder or encoder.\n" + 
        "\n" + 
        "Subclasses should override.\n" + 
        "";

    public final static String TextIOBase_fileno_doc = 
        "Returns underlying file descriptor if one exists.\n" + 
        "\n" + 
        "An IOError is raised if the IO object does not use a file descriptor.";

    public final static String TextIOBase_flush_doc = 
        "Flush write buffers, if applicable.\n" + 
        "\n" + 
        "This is not implemented for read-only and non-blocking streams.";

    public final static String TextIOBase_isatty_doc = 
        "Return whether this is an 'interactive' stream.\n" + 
        "\n" + 
        "Return False if it can't be determined.";

    public final static String TextIOBase_newlines_doc = 
        "Line endings translated so far.\n" + 
        "\n" + 
        "Only line endings translated during reading are considered.\n" + 
        "\n" + 
        "Subclasses should override.\n" + 
        "";

    public final static String TextIOBase_read_doc = 
        "Read at most n characters from stream.\n" + 
        "\n" + 
        "Read from underlying buffer until we have n characters or we hit EOF.\n" + 
        "If n is negative or omitted, read until EOF.\n" + 
        "";

    public final static String TextIOBase_readable_doc = 
        "Return whether object was opened for reading.\n" + 
        "\n" + 
        "If False, read() will raise UnsupportedOperation.";

    public final static String TextIOBase_readline_doc = 
        "Read until newline or EOF.\n" + 
        "\n" + 
        "Returns an empty string if EOF is hit immediately.\n" + 
        "";

    public final static String TextIOBase_readlines_doc = 
        "Return a list of lines from the stream.\n" + 
        "\n" + 
        "hint can be specified to control the number of lines read: no more\n" + 
        "lines will be read if the total size (in bytes/characters) of all\n" + 
        "lines so far exceeds hint.";

    public final static String TextIOBase_seek_doc = 
        "Change stream position.\n" + 
        "\n" + 
        "Change the stream position to the given byte offset. The offset is\n" + 
        "interpreted relative to the position indicated by whence.  Values\n" + 
        "for whence are:\n" + 
        "\n" + 
        "* 0 -- start of stream (the default); offset should be zero or positive\n" + 
        "* 1 -- current stream position; offset may be negative\n" + 
        "* 2 -- end of stream; offset is usually negative\n" + 
        "\n" + 
        "Return the new absolute position.";

    public final static String TextIOBase_seekable_doc = 
        "Return whether object supports random access.\n" + 
        "\n" + 
        "If False, seek(), tell() and truncate() will raise UnsupportedOperation.\n" + 
        "This method may need to do a test seek().";

    public final static String TextIOBase_tell_doc = 
        "Return current stream position.";

    public final static String TextIOBase_truncate_doc = 
        "Truncate file to size bytes.\n" + 
        "\n" + 
        "File pointer is left unchanged.  Size defaults to the current IO\n" + 
        "position as reported by tell().  Returns the new size.";

    public final static String TextIOBase_writable_doc = 
        "Return whether object was opened for writing.\n" + 
        "\n" + 
        "If False, write() will raise UnsupportedOperation.";

    public final static String TextIOBase_write_doc = 
        "Write string to stream.\n" + 
        "Returns the number of characters written (which is always equal to\n" + 
        "the length of the string).\n" + 
        "";

    public final static String TextIOBase_writelines_doc = 
        "";

}
