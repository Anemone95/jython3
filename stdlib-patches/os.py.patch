--- lib-python/2.7/os.py	2015-04-18 05:34:44.715111410 +0300
+++ Lib/os.py	2015-04-18 05:34:31.787089766 +0300
@@ -38,8 +38,9 @@
     except AttributeError:
         return [n for n in dir(module) if n[0] != '_']
 
+name = 'java'
 if 'posix' in _names:
-    name = 'posix'
+    _name = 'posix'
     linesep = '\n'
     from posix import *
     try:
@@ -53,7 +54,7 @@
     del posix
 
 elif 'nt' in _names:
-    name = 'nt'
+    _name = 'nt'
     linesep = '\r\n'
     from nt import *
     try:
@@ -67,7 +68,7 @@
     del nt
 
 elif 'os2' in _names:
-    name = 'os2'
+    _name = 'os2'
     linesep = '\r\n'
     from os2 import *
     try:
@@ -85,7 +86,7 @@
     del os2
 
 elif 'ce' in _names:
-    name = 'ce'
+    _name = 'ce'
     linesep = '\r\n'
     from ce import *
     try:
@@ -100,7 +101,7 @@
     del ce
 
 elif 'riscos' in _names:
-    name = 'riscos'
+    _name = 'riscos'
     linesep = '\n'
     from riscos import *
     try:
@@ -113,6 +114,20 @@
     __all__.extend(_get_exports_list(riscos))
     del riscos
 
+elif 'ibmi' in _names:
+    _name = 'ibmi'
+    linesep = '\n'
+    from ibmi import *
+    try:
+        from ibmi import _exit
+    except ImportError:
+        pass
+    import posixpath as path
+
+    import ibmi
+    __all__.extend(_get_exports_list(ibmi))
+    del ibmi
+
 else:
     raise ImportError, 'no os specific module found'
 
@@ -204,7 +219,7 @@
         except error:
             pass
 
-__all__.extend(["makedirs", "removedirs", "renames"])
+__all__.extend(["makedirs", "removedirs", "renames", "system"])
 
 def walk(top, topdown=True, onerror=None, followlinks=False):
     """Directory tree generator.
@@ -263,7 +278,7 @@
             dirs.remove('CVS')  # don't visit CVS directories
     """
 
-    islink, join, isdir = path.islink, path.join, path.isdir
+    from os.path import join, isdir, islink
 
     # We may not have read permission for top, in which case we can't
     # get a list of the files the directory contains.  os.path.walk
@@ -289,9 +304,9 @@
     if topdown:
         yield top, dirs, nondirs
     for name in dirs:
-        new_path = join(top, name)
-        if followlinks or not islink(new_path):
-            for x in walk(new_path, topdown, onerror, followlinks):
+        path = join(top, name)
+        if followlinks or not islink(path):
+            for x in walk(path, topdown, onerror, followlinks):
                 yield x
     if not topdown:
         yield top, dirs, nondirs
@@ -304,89 +319,96 @@
 except NameError:
     environ = {}
 
-def execl(file, *args):
-    """execl(file, *args)
+def _exists(name):
+    # CPython eval's the name, whereas looking in __all__ works for
+    # Jython and is much faster
+    return name in __all__
 
-    Execute the executable file with argument list args, replacing the
-    current process. """
-    execv(file, args)
-
-def execle(file, *args):
-    """execle(file, *args, env)
-
-    Execute the executable file with argument list args and
-    environment env, replacing the current process. """
-    env = args[-1]
-    execve(file, args[:-1], env)
-
-def execlp(file, *args):
-    """execlp(file, *args)
-
-    Execute the executable file (which is searched for along $PATH)
-    with argument list args, replacing the current process. """
-    execvp(file, args)
-
-def execlpe(file, *args):
-    """execlpe(file, *args, env)
-
-    Execute the executable file (which is searched for along $PATH)
-    with argument list args and environment env, replacing the current
-    process. """
-    env = args[-1]
-    execvpe(file, args[:-1], env)
-
-def execvp(file, args):
-    """execvp(file, args)
-
-    Execute the executable file (which is searched for along $PATH)
-    with argument list args, replacing the current process.
-    args may be a list or tuple of strings. """
-    _execvpe(file, args)
-
-def execvpe(file, args, env):
-    """execvpe(file, args, env)
-
-    Execute the executable file (which is searched for along $PATH)
-    with argument list args and environment env , replacing the
-    current process.
-    args may be a list or tuple of strings. """
-    _execvpe(file, args, env)
-
-__all__.extend(["execl","execle","execlp","execlpe","execvp","execvpe"])
-
-def _execvpe(file, args, env=None):
-    if env is not None:
-        func = execve
-        argrest = (args, env)
-    else:
-        func = execv
-        argrest = (args,)
-        env = environ
-
-    head, tail = path.split(file)
-    if head:
-        func(file, *argrest)
-        return
-    if 'PATH' in env:
-        envpath = env['PATH']
-    else:
-        envpath = defpath
-    PATH = envpath.split(pathsep)
-    saved_exc = None
-    saved_tb = None
-    for dir in PATH:
-        fullname = path.join(dir, file)
-        try:
-            func(fullname, *argrest)
-        except error, e:
-            tb = sys.exc_info()[2]
-            if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR
-                and saved_exc is None):
-                saved_exc = e
-                saved_tb = tb
-    if saved_exc:
-        raise error, saved_exc, saved_tb
-    raise error, e, tb
+if _exists('execv'):
+
+    def execl(file, *args):
+        """execl(file, *args)
+
+        Execute the executable file with argument list args, replacing the
+        current process. """
+        execv(file, args)
+
+    def execle(file, *args):
+        """execle(file, *args, env)
+
+        Execute the executable file with argument list args and
+        environment env, replacing the current process. """
+        env = args[-1]
+        execve(file, args[:-1], env)
+
+    def execlp(file, *args):
+        """execlp(file, *args)
+
+        Execute the executable file (which is searched for along $PATH)
+        with argument list args, replacing the current process. """
+        execvp(file, args)
+
+    def execlpe(file, *args):
+        """execlpe(file, *args, env)
+
+        Execute the executable file (which is searched for along $PATH)
+        with argument list args and environment env, replacing the current
+        process. """
+        env = args[-1]
+        execvpe(file, args[:-1], env)
+
+    def execvp(file, args):
+        """execp(file, args)
+
+        Execute the executable file (which is searched for along $PATH)
+        with argument list args, replacing the current process.
+        args may be a list or tuple of strings. """
+        _execvpe(file, args)
+
+    def execvpe(file, args, env):
+        """execvpe(file, args, env)
+
+        Execute the executable file (which is searched for along $PATH)
+        with argument list args and environment env , replacing the
+        current process.
+        args may be a list or tuple of strings. """
+        _execvpe(file, args, env)
+
+    __all__.extend(["execl","execle","execlp","execlpe","execvp","execvpe"])
+
+    def _execvpe(file, args, env=None):
+        if env is not None:
+            func = execve
+            argrest = (args, env)
+        else:
+            func = execv
+            argrest = (args,)
+            env = environ
+
+        head, tail = path.split(file)
+        if head:
+            func(file, *argrest)
+            return
+        if 'PATH' in env:
+            envpath = env['PATH']
+        else:
+            envpath = defpath
+        PATH = envpath.split(pathsep)
+        saved_exc = None
+        saved_tb = None
+        for dir in PATH:
+            fullname = path.join(dir, file)
+            try:
+                func(fullname, *argrest)
+            except error, e:
+                tb = sys.exc_info()[2]
+                if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR
+                    and saved_exc is None):
+                    saved_exc = e
+                    saved_tb = tb
+        if saved_exc:
+            raise error, saved_exc, saved_tb
+        raise error, e, tb
 
 # Change environ to automatically call putenv() if it exists
 try:
@@ -395,8 +417,6 @@
 except NameError:
     pass
 else:
-    import UserDict
-
     # Fake unsetenv() for Windows
     # not sure about os2 here but
     # I'm guessing they are the same.
@@ -405,10 +425,12 @@
         def unsetenv(key):
             putenv(key, "")
 
-    if name == "riscos":
+    if _name == "riscos":
         # On RISC OS, all env access goes through getenv and putenv
         from riscosenviron import _Environ
-    elif name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE
+    elif _name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE
+        import UserDict
+
         # But we store them as upper case
         class _Environ(UserDict.IterableUserDict):
             def __init__(self, environ):
@@ -417,26 +439,11 @@
                 for k, v in environ.items():
                     data[k.upper()] = v
             def __setitem__(self, key, item):
-                putenv(key, item)
                 self.data[key.upper()] = item
             def __getitem__(self, key):
                 return self.data[key.upper()]
-            try:
-                unsetenv
-            except NameError:
-                def __delitem__(self, key):
-                    del self.data[key.upper()]
-            else:
-                def __delitem__(self, key):
-                    unsetenv(key)
-                    del self.data[key.upper()]
-                def clear(self):
-                    for key in self.data.keys():
-                        unsetenv(key)
-                        del self.data[key]
-                def pop(self, key, *args):
-                    unsetenv(key)
-                    return self.data.pop(key.upper(), *args)
+            def __delitem__(self, key):
+                del self.data[key.upper()]
             def has_key(self, key):
                 return key.upper() in self.data
             def __contains__(self, key):
@@ -462,50 +469,7 @@
             def copy(self):
                 return dict(self)
 
-    else:  # Where Env Var Names Can Be Mixed Case
-        class _Environ(UserDict.IterableUserDict):
-            def __init__(self, environ):
-                UserDict.UserDict.__init__(self)
-                self.data = environ
-            def __setitem__(self, key, item):
-                putenv(key, item)
-                self.data[key] = item
-            def update(self,  dict=None, **kwargs):
-                if dict:
-                    try:
-                        keys = dict.keys()
-                    except AttributeError:
-                        # List of (key, value)
-                        for k, v in dict:
-                            self[k] = v
-                    else:
-                        # got keys
-                        # cannot use items(), since mappings
-                        # may not have them.
-                        for k in keys:
-                            self[k] = dict[k]
-                if kwargs:
-                    self.update(kwargs)
-            try:
-                unsetenv
-            except NameError:
-                pass
-            else:
-                def __delitem__(self, key):
-                    unsetenv(key)
-                    del self.data[key]
-                def clear(self):
-                    for key in self.data.keys():
-                        unsetenv(key)
-                        del self.data[key]
-                def pop(self, key, *args):
-                    unsetenv(key)
-                    return self.data.pop(key, *args)
-            def copy(self):
-                return dict(self)
-
-
-    environ = _Environ(environ)
+        environ = _Environ(environ)
 
 def getenv(key, default=None):
     """Get an environment variable, return None if it doesn't exist.
@@ -513,9 +477,6 @@
     return environ.get(key, default)
 __all__.append("getenv")
 
-def _exists(name):
-    return name in globals()
-
 # Supply spawn*() (probably only for Unix)
 if _exists("fork") and not _exists("spawnv") and _exists("execv"):
 
@@ -651,7 +612,7 @@
 
 
 # Supply popen2 etc. (for Unix)
-if _exists("fork"):
+if sys.platform.startswith('java') or _exists("fork"):
     if not _exists("popen2"):
         def popen2(cmd, mode="t", bufsize=-1):
             """Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'
@@ -660,10 +621,6 @@
             is a string it will be passed to the shell (as with os.system()). If
             'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
             file objects (child_stdin, child_stdout) are returned."""
-            import warnings
-            msg = "os.popen2 is deprecated.  Use the subprocess module."
-            warnings.warn(msg, DeprecationWarning, stacklevel=2)
-
             import subprocess
             PIPE = subprocess.PIPE
             p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),
@@ -680,10 +637,6 @@
             is a string it will be passed to the shell (as with os.system()). If
             'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
             file objects (child_stdin, child_stdout, child_stderr) are returned."""
-            import warnings
-            msg = "os.popen3 is deprecated.  Use the subprocess module."
-            warnings.warn(msg, DeprecationWarning, stacklevel=2)
-
             import subprocess
             PIPE = subprocess.PIPE
             p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),
@@ -700,10 +653,6 @@
             is a string it will be passed to the shell (as with os.system()). If
             'bufsize' is specified, it sets the buffer size for the I/O pipes.  The
             file objects (child_stdin, child_stdout_stderr) are returned."""
-            import warnings
-            msg = "os.popen4 is deprecated.  Use the subprocess module."
-            warnings.warn(msg, DeprecationWarning, stacklevel=2)
-
             import subprocess
             PIPE = subprocess.PIPE
             p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),
@@ -712,29 +661,75 @@
             return p.stdin, p.stdout
         __all__.append("popen4")
 
-import copy_reg as _copy_reg
+if not _exists("urandom"):
+    def urandom(n):
+        """urandom(n) -> str
 
-def _make_stat_result(tup, dict):
-    return stat_result(tup, dict)
+        Return a string of n random bytes suitable for cryptographic use.
 
-def _pickle_stat_result(sr):
-    (type, args) = sr.__reduce__()
-    return (_make_stat_result, args)
-
-try:
-    _copy_reg.pickle(stat_result, _pickle_stat_result, _make_stat_result)
-except NameError: # stat_result may not exist
-    pass
-
-def _make_statvfs_result(tup, dict):
-    return statvfs_result(tup, dict)
-
-def _pickle_statvfs_result(sr):
-    (type, args) = sr.__reduce__()
-    return (_make_statvfs_result, args)
+        """
+        try:
+            _urandomfd = open("/dev/urandom", O_RDONLY)
+        except (OSError, IOError):
+            raise NotImplementedError("/dev/urandom (or equivalent) not found")
+        bytes = ""
+        while len(bytes) < n:
+            bytes += read(_urandomfd, n - len(bytes))
+        close(_urandomfd)
+        return bytes
+
+# Supply os.popen()
+def popen(cmd, mode='r', bufsize=-1):
+    """popen(command [, mode='r' [, bufsize]]) -> pipe
 
-try:
-    _copy_reg.pickle(statvfs_result, _pickle_statvfs_result,
-                     _make_statvfs_result)
-except NameError: # statvfs_result may not exist
-    pass
+    Open a pipe to/from a command returning a file object.
+    """
+    if not isinstance(cmd, (str, unicode)):
+        raise TypeError('invalid cmd type (%s, expected string)' % type(cmd))
+    if mode not in ('r', 'w'):
+        raise ValueError("invalid mode %r" % mode)
+    import subprocess
+    if mode == 'r':
+        proc = subprocess.Popen(cmd, bufsize=bufsize, shell=True,
+                                stdout=subprocess.PIPE)
+        fp = proc.stdout
+    elif mode == 'w':
+        proc = subprocess.Popen(cmd, bufsize=bufsize, shell=True,
+                                stdin=subprocess.PIPE)
+        fp = proc.stdin
+    # files from subprocess are in binary mode but popen needs text mode
+    fp = fdopen(fp.fileno(), mode, bufsize)
+    return _wrap_close(fp, proc)
+
+# Helper for popen() -- a proxy for a file whose close waits for the process
+class _wrap_close(object):
+    def __init__(self, stream, proc):
+        self._stream = stream
+        self._proc = proc
+    def close(self):
+        self._stream.close()
+        returncode = self._proc.wait()
+        if returncode == 0:
+            return None
+        if _name == 'nt':
+            return returncode
+        else:
+            return returncode
+    def __getattr__(self, name):
+        return getattr(self._stream, name)
+    def __iter__(self):
+        return iter(self._stream)
+
+
+def system(command):
+    """system(command) -> exit_status
+
+    Execute the command (a string) in a subshell."""
+    # Because this is a circular import, we need to perform
+    # a late binding. Monkeypatch to avoid doing this import
+    # repeatedly.
+    global system  # writable name of this function!
+    
+    from subprocess import _os_system
+    system = _os_system
+    return _os_system(command)
